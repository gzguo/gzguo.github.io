<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jdbc_start]]></title>
    <url>%2F2019%2F08%2F16%2FJDBC%2Fall%2F</url>
    <content type="text"><![CDATA[JDBC全面了解&gt; JDBC简介 jdbc是Java Database Connectivity的缩写，即java数据库连接思想，使用jdbc可以实现对数据库的访问 我们都知道，java是跨操作平台的，而通过jdbc可以实现跨数据库平台，jdbc只是一个抽象的编程接口，通过加载不同的数据库驱动，可以实现不同数据库的通信，例如：Mysql、Oracl、SqlServer 在java中有两个包java.sql和javax.sql包含jdbc编程的所有接口 在java中常用接口和类如下：DriverManger 驱动管理器获得数据库链接、Connect 数据库连接接口、Statement 语句接口，用来静态操作SQL语句、PreparedStatement 预定义语句，用来动态操作SQL语句、CallableStatement 可以调用存储过程的预定义语句、ResultSet 结果集，保存数据记录的结果集合、ResultMetaData 结果集元数据，如：列名称、列类型 、DatabaseMetaData 数据库元数据，如：数据库名称、版本 jdbc的编程步骤：1.加载数据库驱动（jar文件） 2.获取数据库连接 3.创建语句 4.执行查询 5.遍历结果集 6.关闭数据库连接 数据库连接 获得数据库连接是操作数据库的第一步，是应用程序和数据库的一个“握手”过程 数据库打开的连接数是有限的，所以连接使用完成需要关闭 获得数据库连接的步骤：1.加载驱动(Class.forName) 2.获得连接(DriverManager 是获取数据库连接的一个工厂(实例化的作用) DriverManager.getConnection()) 创建数据库连接的时候，可以通过配置文件来加载固定格式的url、username、password等 Statement语句 Statement语句是SQL语句的描述，使用它可以操作各种SQL语句，包括DDL(数据库定义语句，如创建表)、DML(CRUD)和DCL等 使用Statement创建表 ResultSet结果集 用来获得SQL语句查询结果 结果集包含了SQL语句的查询结果数据 调用语句的excuteQuery方法返回结果集对象 ResultSet常用方法 next：返回boolean类型数据，用来判断结果集中是否有数据 getXXX：获得结果集中的数据项(可以根据列名称、可以根据列索引) PreparedStatement PreparedStatement为预定义语句，继承Statement Statement只能静态操作SQL语句，如果要操作动态SQL，这里可以使用PreparedStatement来动态操作SQL语句，PreparedStatement通过使用占位符“？”，来预生成SQL语句，从而达到动态操作的功能 12345678910111213static void insert(String name,String email)&#123; String sql = "insert into CustomrTbl(name,email) values(?,?);"; Connection conn = DBUtil.open(); try&#123; PreparedStatement pstmt = conn.prepareStatement(sql); pstmt.setString(1,name); pstmt.setString(2,email); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; DBUtil.close(conn); &#125;&#125; CallableStatement调用后台写好的存储过程 CallableStatement继承PreParedStatement，提供了调用存储过程的能力 CallableStatement用法：1.调用简单的存储过程 2.调用有输入参数的存储过程 3.调用有输入、输出参数的存储过程 实例：1.命令行创建存储过程：create procedure/pro all_customers() select * from CustomerTbl; 2.命令行调用：call all_customers(); 3.使用CallableStatement调用 1234567891011121314static void test()&#123; Connection conn = DBUtil.open(); try&#123; CallableStatement cstmt = conn.prepareCall("&#123;call all_customers()&#125;"); ResultSet rs = cstmt.executeQuery(); while(rs.next())&#123; int id = rs.getInt(1); String name = rs.getString(2); String email = rs.getString(3); System.out.println("id:"+id+","+"name:"+name+","+"email:"+email); &#125; &#125; &#125; 12//这是创建存储过程，in代表输入参数create procedure insert_customer(in myname varchar(20),in myemail varchar(20)) insert into CustomerTbl(name,email) values(myname,myemail); 1create procedure getnamebyid(in cid int,out return_name varchar(20)) select name into return_name from CustomerTbl where id = cid; 1234567891011121314151617static void test()&#123; Connection conn = DBUtil.open(); try&#123; CallableStatement cstmt = conn.prepareCall("&#123;call getnamebyid(?,?)&#125;"); cstmt.setInt(1,6); //注册输入参数 cstmt.registerOutParameter(2,Types.CHAR); cstmt.excute(); String email = cstmt.getString(2); cstmt.executeUpdate(); System.out.println(email); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally&#123; DBUtil.close(conn); &#125;&#125; DAO设计模式 DAO简介 DAO的全称是：Data Access Object，数据访问对象，使用DAO设计模式，来封装数据库持久层操作(CRUD)，使低级的数据逻辑和高级的业务逻辑分离，达到解耦合的目的 一个典型的DAO实现有如下的组件：一个DAO接口、数据传输对象(有时称为值对象)、一个实现DAO接口的具体类、一个DAO工厂类 以维护一个客户信息为例，具体组件如下：CustomerDao接口、Customer值对象(VO)、CustomerDaoImpl(接口工具实现类)、CustomerFactory(工厂类、实例化用) Dao接口：里面写很多方法来进行增删改查 Dao实现类：实现这些方法]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql_start]]></title>
    <url>%2F2019%2F08%2F16%2Fmysql%2Fstart%2F</url>
    <content type="text"><![CDATA[mysql对数据库和数据表的操作 mysql操作数据库和数据表create table 表名(字段名 类型 主键 非空); 建表 create database 数据库名; 建库 use 数据库名; 使用某个数据库 show databases：查看数据库 show tables：查看数据表 describe/desc 表名：查看表结构 select * from 表名：查看表内数据 mysql增删改查select * from 表名; //get insert into 表名(字段名) values(字段值); //post update 表名 set 字段名 = ‘字段值’; //put delete from 表名 where id = ‘字段值’; //delete mysql的约束primary key主键约束：是每条信息的唯一信息，主键不能重复，主键禁止为空，主键一般标志到无意义的字段上 auto_increment自动递增：从一开始自增 唯一约束：约束修饰的字段的不能重复 非空约束：not null不能为null 默认约束：default当我们插入字段的时候，如果没有传值，就会使用默认值 外键约束：foreign key references 结论：1.主表中没有的数据，在副表中是不可以使用的 ​ 2.主表中的记录被副表引用，那么主表中的这条记录是不可以被删除的 涉及到两个表：父表、子表（主表、副表） 主表不能随意删，副表不能随便加 小例子：foreigen key(子表字段名) references 父表(父表中的字段名); mysql对时区和密码的操作SELECT @@global.time_zone; // global.time_zoneSELECT @@global.system_time_zone; // globle.system_timeshow variables like “%time_zone%”; // Variable_name,Valueselect now(); // now() ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘root’; 修改数据库密码 select @@autocommit; mysql的事务开启状态：是否自动提交 1 自动提交 2 非自动提交 mysql修改表结构：给某个字段添加主键约束： alter table 表名 add primary key(字段名); //直接增加 alter table 表名 modify 字段名 类型 primary key; //修改字段间接增加 删除主键约束：alter table 表名 drop primary key; 添加唯一约束： alter table 表名 add unique(字段名); alter table 表名 modify 字段名 类型 unique; 删除唯一约束：alter table 表名 drop index 字段名; 设计数据库的格式：第一范式：数据表中的所有字段都是不可分割的原子值 根据字段值还可以继续拆分的，不满主第一范式 范式，设计的越详细，对于某些实际操作可能更好，但不一定都是好处 第二范式满足第一范式的前提下，第二范式要求，除主键外的每一列都必须完全依赖于主键 如果要出现不完全依赖，只可能发生在联合主键的情况下 除主键之外的其他列，只依赖与主键的部分字段：拆表 第三范式必须满足第二范式 除主键列的其他列之间不能用传递依赖关系]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java_start]]></title>
    <url>%2F2019%2F08%2F16%2Fjava%2Fstart%2F</url>
    <content type="text"><![CDATA[标识符、变量、常量、数据类型、运算符 语言发展史机器语言、汇编语言、高级语言 计算机高级语言的类型编译型：c++、c（源码被编译完之后直接给系统） 解释型：javascript、Python、Php java是编译型语言和解释型语言的结合（源码文件（.java）被编译为class文件（字节码文件）然后被JRE处理（类加载器、字节码校验器、解释器（虚拟机）））最后JRE给了系统**java–&gt;JVM–&gt;底层操作系统，经过这么一个中介我们java避免了与操作系统直接打交道，这样实现跨平台的核心机制（JRE是java运行时环境，包括了虚拟机JVM）** 脚本语言：javascript、Python、Php 编译语言：java 标记语言：Html、xml 高级语言安卓开发：Kotlin 苹果（IOs）开发：Objective-C、Swift Fortran世界上第一种高级语言IBM公司提出的 Basic、COBOL、Pasacl都是老一辈的开发语言 java：称之为c++-，广泛用于企业级软件开发、安卓移动开发、大数据云计算等领域，几乎涉及IT所有行业。IBM、Oracle、Sun（被Oracle收购）都支持java，形成了一个生态体系，主要是因为Java的开源性。java的优势：跨平台/可移植性、多线程、分布式、高性能、健壮性 Python：蟒蛇，又称之为胶水语言（可以和c、c++整合），广泛应用于：图形处理、科学计算、web编程、多媒体应用、引擎开发；尤其是在未来大热方向机器学习和人工智能上有非常大的潜力 c语言、c++、c#都很优秀，所有的语言都是c发展而来的 php是世界上最好的语言，用于大型web开发 javascript：用于前端页面渲染 java的运行环境JVM、JRE、JDKJVM（Java Virtual Machine）：源码经过编译器编程字节码，字节码被JVM解释执行。JVM与操作系统打交道 JRE（Java Runtime Environment）：包含Java虚拟机、库函数、运行Java应用程序所必须的文件 JDK（Java Delelopment Kit）：Java开发工具包，包含了JRE，以及增加了编译器和调试器等用于程序开发的文件 如果运行Java只需要有JRE就行，开发Java要有JDK 正是因为有了虚拟机（JVM）我们才实现了跨平台（JVM for Unix、JVM for Windows、JVM for Other）由官方统一给各个系统提供了标准的虚拟机 安装JDK目录结构bin目录：二进制的exe文件（java（调用虚拟机）、javac（调用编译器）） db目录：一些数据 include目录：头文件 lib目录：库Java的jar包（jar包：字节码文件打包） src.zip：java源码的目录 环境变量环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息 设置Path环境变量运行某个程序的时候，系统会去Path指定的目录中去找这个程序对应的文件 java标识符、关键字、变常量标识符标识符是用来给变量、类、方法以及包进行命名的，如Welcome、main、System、age、name、gender等。标识符需要遵守一定的规则： 标识符必须以字母、下划线_、美元符号$开头 标识符其他部分可以是字母、下划线、美元符和数字的任意组合 java标识符大小写敏感，且长度无限制 标识符不可以是关键字 标识符的使用规范 表示类名的标识符：每个单词的首字母大写，如Man，GoodMan 表示方法和变量的标识符：第一个单词小写，从第二个单词开始首字母大写，我们称之为”驼峰原则”，如eat()，eatFood() 注意：java不采用通常语言使用的ASCII字符集，而是使用Unicode这样标准的国际字符集。因此，这里字母的含义不仅仅是英文，还包括汉字等等。但是不建议大家使用汉字来定义标识符 关键字/保留字java关键字是保留供内部使用的，如class用于定义类。关键字也可以称为保留字，他们的意思是一样的，我们不能使用关键字作为变量名或方法名 关键字详解 变量变量的本质 变量的本质上就是代表一个“可操作的存储空间”，空间位置是确定的，但是里面放置什么值不确定。我们可以通过变量名来访问”对应的存储空间“，从而操纵这个”存储空间“存储的值。 java是一种强类型语言，每个变量都必须声明其数据类型。变量的数据类型决定了变量占据存储空间的大小。比如，int a=3;表示变量a变量的空间大小为4个字节。 变量作为程序中最基本的存储单元，其要素包括变量名、变量类型和作用域。变量在使用前必须对其声明，只有在变量声明以后，才能为其分配相应长度的存储空间。 不同的数据类型的常量会在内存中分配不同的空间 注意事项 每个变量都会有类型，类型可以是基本类型，也可以是引用类型 变量名必须是合法的标识符 变量声明是一条完整的语句，因此每一个声明都必须以分号结束 方法中的变量必须声明、赋值之后才可以使用 变量的分类 局部变量：方法或语句块内定义的变量。生命周期从声明位置开始到方法语句块执行完毕为止。局部变量在使用前必须先声明、初始化(赋初值)再使用 1234//语句块&#123; int age; &#125; 成员变量：(实例变量)方法外部、类的内部定义的变量。从属于对象，生命周期伴随着对象始终。如果不自行初始化，他会自动初始化成该类型的默认初始值 1234int a = 0;double b = 0.0;char c = '\u0000';boolen = false; 静态变量：(类变量)方法外部、类的内部定义的变量。使用static定义，从属于类，生命周期伴随类始终，从类加载到卸载(通常系统启动时会把相应的类进行加载，系统结束的时候卸载这些类)，如果不自行初始化，与成员变量相同会自动初始化成该类型的默认初始化值 常量(Constant)常量一旦被赋值就不能被改变 通过添加关键字final可以将一个变量转变成符号常量 通常1，2，3，’a’这些称之为字面常量 变量和常量命名规范 所有的变量、方法名、类名：见名知义 类成员变量：首字母小写和驼峰原则：monthSalary 局部变量：首字母小写和驼峰原则 常量：大写字母和下划线：MAX_VALUE 类名：首字母大写和驼峰原则 方法名首字母小写和驼峰原则 java数据类型数据类型的分类基本数据类型：(primitive data type)： 数值型：byte(1 byte)、short(2 byte)、int(4 byte)、long(8 byte)、float(4 byte)、double(8 byte) 字符型：char(2 byte) 布尔型：boolean(1 bit) 1 byte(字节) = 8 bit(位) 引用数据类型：(引用对象和变量，4byte) 类(class) 接口(interface) 数组 整形变量/常量 byte(1 byte) short(2 byte) int(4 byte) long(8 byte) 整型常量的四中表示形式 十进制整数：99 八进制整数，要求以0开头：015 十六进制数，要求以0x或0X开头，0x15 二进制数，要求0b或0B开头，0b01110011 整型常量默认为int类型，整型常量后面要加L/l才表示这是一个long类型的常量。这里涉及到了类型转换的问题 浮点变量/常量 十进制数形式：3.14 科学计数法形式：314e2(31400)、314E2(31400)、314E-2(3.14) 浮点常量的默认类型是double，浮点常量后面加F/f表示这是一个float类型的常量 浮点数是不精确的，一定不要用于比较。如果非要比较，可以引用java.math包下的两个有用类BigInteger、BigDecimal，这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。 字符型变量/常量2 byte 注意一下转义字符 看一下String 布尔类型变量/常量占 1 bit 布尔类型有两个常量值：true和false，不可以使用0或非0整数替代true和false，这点和c语言不同。boolean类型用来判断逻辑条件，一般用于程序流程控制 运算符运算符分类(operator) 算术运算符 赋值运算符 关系运算符 逻辑运算符 位运算符 条件运算符 字符串连接符 算术运算符二元运算符算术运算符中+、-、*、/、%属于二元运算符，二元运算符指的是需要两个操作数才能完成运算的运算符。 二元运算符的运算规则整数运算 如果两个操作数有一个为Long，则运算结果也为Long 没有Long时，结果为int。即使操作数全为short、byte，结果也是int 浮点运算 如果有一个数为浮点，则结果为浮点 如果两个操作数有一个是double，则结果为double 只有两个操作数都为float，则结果才为float 取模运算 其操作数可以为浮点数，一般使用整数，结果是余数，余数符号和左边操作数相同，如7%3=1，-7%3=-1，7%-3=1 一元运算符自增、自减 1234int a = 3;int b = a++; //执行完后b=3，先给b赋值，再自增a = 3;b = ++a; //执行完后b=4，a先自增，再给b赋值 赋值运算符及扩展赋值运算符赋值运算符：= 扩展赋值运算符：+=、-=、*=、/=、%= 1a *= b + 3; //相当于a = a * (b + 3)，始终先算后面的结果 关系运算符==、!=、&gt;、&lt;、&gt;=、&lt;= 注意事项 =是赋值运算符，而真正的判断两个操作数是否相等的运算符是== ==、!=是所有(基本类型、引用类型)数据类型都可以使用 &lt;、&lt;=、&gt;、&gt;= 仅针对数值类型(byte、short、int、long，float、double，以及char) 逻辑运算符 逻辑与：&amp; 操作两个布尔值，两个都是true才是true 逻辑或：| 操作两个布尔值，有一个是true就是true 短路与：&amp;&amp; 操作两个布尔值，只要有一个false，就直接返回false 短路或：|| 操作两个布尔值，只要有一个true，就直接返回true 逻辑非：! 操作一个布尔值，true就是false 逻辑异或：^ 操作两个布尔值，两个值相同就是false 位运算符 ~：取反 &amp;：按位与 3&amp;4 (0011&amp;0100：0000) |：按位或 ^：按位异或 &lt;&lt;：左移运算符，左移一位相当于乘2 (&gt;&gt;)：右移运算符，右移一位相当于除2取商 12int a = 3 &lt;&lt; 2;//a的值是12 字符串连接符+：如果左右两边有一个是字符串，那么+就是字符串连接符 123456789String a = "3";int b = 4;int c = 5;char d = 'a';a + b; //结果为34a + c; //结果为35a + b + c; //345 因为从左到右依次计算b + c + a; //93d + 4; //101 'a'=97,97+4=101,这里是算术运算符，不是字符串连接符 条件运算符x:y:z 其中x为boolean表达式，先计算x的值，若为true，则整个运算结果为表达式y的值。否则整个运算结果为表达式z的值，他是三目运算符 运算符的优先级优先级 一些建议 不需要去刻意的去记这些优先级，表达式里面有限使用小括号来组织 逻辑与、逻辑或、逻辑非的优先级：逻辑非&gt;逻辑与&gt;逻辑或]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql_transaction]]></title>
    <url>%2F2019%2F08%2F16%2Fmysql%2Ftransaction%2F</url>
    <content type="text"><![CDATA[mysql事务 mysql事务mysql中，事务其实是一个最小的不可分割的单元，事务能保证一个业务的完整性 比如我们的银行转账 a –&gt;-100 update user set money = money - 10 where name = ‘a’; b –&gt;+100 update user set money = money + 10 where name = ‘b’; 实际的程序中：如果只有一条语句执行成功，而另外一条没有执行成功出现数据前后不一致 123update user set money = money - 10 where name = 'a';update user set money = money + 10 where name = 'b'; 多条sql语句，可能会有同时成功的要求，不然的话就同时失败 mysql如何控制事务：1.mysql默认是开启事务的(自动提交) mysql&gt; select @@autocommit;+————–+| @@autocommit |+————–+| 1 |+————–+1 row in set (0.03 sec) 默认事务开启的作用是：当我们去执行sql语句的时候，效果会立刻体现出来且不能回滚 create database bank; mysql&gt; create table user( -&gt; id int primary key, -&gt; name varchar(20), -&gt; money int -&gt; );Query OK, 0 rows affected (0.04 sec) 1insert into user values(1,'a',1000); 事务回滚：撤销sql语句执行效果 即使执行了rollback，仍然回不到插入数据之前，说明现在不能回滚，有什么办法可以反悔呢？ mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from user;+—-+——+——-+| id | name | money |+—-+——+——-+| 1 | a | 1000 |+—-+——+——-+1 rows in set (0.04 sec) 有什么办法可以反悔呢？ 设置mysql自动提交为false：*set autocommit = 0;*** 上面的操作关闭了mysql的自动提交（commit） 1insert into user values(2,'b',1000); mysql&gt; select * from user;+—-+——+——-+| id | name | money |+—-+——+——-+| 1 | a | 1000 || 2 | b | 1000 |+—-+——+——-+2 rows in set (0.03 sec) mysql&gt; rollback;Query OK, 0 rows affected (0.01 sec) mysql&gt; select * from user;+—-+——+——-+| id | name | money |+—-+——+——-+| 1 | a | 1000 |+—-+——+——-+1 row in set (0.02 sec) 现在可以取消插入的操作了 mysql&gt; insert into user values(2,’b’,1000);Query OK, 1 row affected (0.01 sec) mysql&gt; commit;Query OK, 0 rows affected (0.00 sec) mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from user;+—-+——+——-+| id | name | money |+—-+——+——-+| 1 | a | 1000 || 2 | b | 1000 |+—-+——+——-+2 rows in set (0.03 sec) *事务：自动提交 autocommit = 1* *手动提交 自己打commit命令* *事务回滚 rollback* 如果说这个时候转账 12update user set money = money - 10 where name = 'a'; update user set money = money + 10 where name = 'b'; mysql&gt; update user set money = money - 10 where name = ‘a’; update user set money = money + 10 where name = ‘b’;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from user;+—-+——+——-+| id | name | money |+—-+——+——-+| 1 | a | 990 || 2 | b | 1010 |+—-+——+——-+2 rows in set (0.05 sec) mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from user;+—-+——+——-+| id | name | money |+—-+——+——-+| 1 | a | 1000 || 2 | b | 1000 |+—-+——+——-+2 rows in set (0.04 sec) 事务给我们提供一个反悔的机会 begin;或者start transaction;都可以帮我们手动开启一个事务 mysql&gt; update user set money = money - 10 where name = ‘a’; update user set money = money + 10 where name = ‘b’;Query OK, 1 row affected (0.02 sec)Rows matched: 1 Changed: 1 Warnings: 0Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from user;+—-+——+——-+| id | name | money |+—-+——+——-+| 1 | a | 990 || 2 | b | 1010 |+—-+——+——-+2 rows in set (0.04 sec) mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from user;+—-+——+——-+| id | name | money |+—-+——+——-+| 1 | a | 990 || 2 | b | 1010 |+—-+——+——-+2 rows in set (0.04 sec) begin; 手动开启事务（start transaction） 12update user set money = money - 10 where name = 'a'; update user set money = money + 10 where name = 'b'; mysql&gt; begin; update user set money = money - 10 where name = ‘a’; update user set money = money + 10 where name = ‘b’;Query OK, 0 rows affected (0.00 sec) Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from user;+—-+——+——-+| id | name | money |+—-+——+——-+| 1 | a | 980 || 2 | b | 1020 |+—-+——+——-+2 rows in set (0.04 sec) mysql&gt; rollback;Query OK, 0 rows affected (0.01 sec) mysql&gt; select * from user;+—-+——+——-+| id | name | money |+—-+——+——-+| 1 | a | 990 || 2 | b | 1010 |+—-+——+——-+2 rows in set (0.04 sec) 注意事务开启之后，一旦commit（提交），就不可以回滚（事务在提交的时候就结束了） 事物的特征：事物的四大特征： 1.原子性（A）：事务是最小的单位，不可再分割 2.一致性（C）：事务要求，同一事务的sql语句，必须保证同时成功或者同时失败 3.隔离性（I）：事务1和事务2之间是具有隔离性的 4.持久性（D）：事务一旦结束（commit，rollback），就不可返回 事务开启： 1.修改默认提交：set sutocommit = 0; 2.begin; 3.start transaction; 事务手动提交：commit; 事务手动回滚：rollback; 事物的隔离性:1.read uncommitted; 读未提交的 2.read committed; 读已提交的 3.repeatable read; 可以重复读 4.serializable; 串行化 1.read uncommitted;如果有事务a和事务b，a事务对数据进行操作，事务没有被提交，但是b可以看到a操作的结果 bank数据库 user表 123insert into user values(3,'小明',1000);insert into user values(4,'淘宝店',1000); 小明去淘宝店买东西，淘宝店查看钱是否到账？ 如何查看数据库的隔离级别？ mysql8.0 系统级别： select @@global.transaction_isolation; 会话级别： select @@transaction_isolation; mysql&gt; select @@global.transaction_isolation; mysql默认隔离级别： +——————————–+| @@global.transaction_isolation |+——————————–+| REPEATABLE-READ |+——————————–+1 row in set (0.04 sec) mysql 5.x select @@global.tx_isolation; select @@tx_isolation; 如何修改隔离级别？ 1set global transaction isolation level read uncommitted; mysql&gt; set global transaction isolation level read uncommitted;Query OK, 0 rows affected (0.02 sec) mysql&gt; select @@global.transaction_isolation;+——————————–+| @@global.transaction_isolation |+——————————–+| READ-UNCOMMITTED |+——————————–+1 row in set (0.04 sec) 好了开始转帐，小明买鞋子：800块钱 小明》》城都 ATM 淘宝店》》广州 ATM mysql&gt; select * from user;+—-+——–+——-+| id | name | money |+—-+——–+——-+| 1 | a | 980 || 2 | b | 1020 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 |+—-+——–+——-+4 rows in set (0.05 sec) start transaction; 123update user set money = money-800 where name = '小明';update user set money = money+800 where name = '淘宝店'; mysql&gt; start transaction; update user set money = money-800 where name = ‘小明’; update user set money = money+800 where name = ‘淘宝店’;Query OK, 0 rows affected (0.00 sec) Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from user;+—-+——–+——-+| id | name | money |+—-+——–+——-+| 1 | a | 980 || 2 | b | 1020 || 3 | 小明 | 200 || 4 | 淘宝店 | 1800 |+—-+——–+——-+4 rows in set (0.04 sec) 给淘宝店打电话，说你去查一下，是不是到账了 淘宝店在广州查账 发货 淘宝店晚上请女朋友吃好吃的 1800 小明rollback mysql&gt; rollback;Query OK, 0 rows affected (0.01 sec) mysql&gt; select * from user;+—-+——–+——-+| id | name | money |+—-+——–+——-+| 1 | a | 980 || 2 | b | 1020 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 |+—-+——–+——-+4 rows in set (0.04 sec) 结账的时候发现钱不够 如果两个不同的地方，都在进行操作，如果事务a开启之后，他的数据可以被其他事务读取到 这样就会出现脏读 脏读：一个事务读取到另外一个事物没有提交的数据就叫做脏读 实际开发不允许脏读出现 2.read committed;123set global transaction isolation level read committed;select @@global.transaction_isolation; mysql&gt; set global transaction isolation level read committed; select @@global.transaction_isolation;Query OK, 0 rows affected (0.00 sec) +——————————–+| @@global.transaction_isolation |+——————————–+| READ-COMMITTED |+——————————–+1 row in set (0.03 sec) bank数据库 user表 小张：银行的会计 start transaction; select * from user; mysql&gt; select * from user;+—-+——–+——-+| id | name | money |+—-+——–+——-+| 1 | a | 980 || 2 | b | 1020 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 |+—-+——–+——-+4 rows in set (0.04 sec) 小张上厕所去了。。。顺便抽烟 小王： 123start transaction;insert into user values(5,'c',100); commit; mysql&gt; start transaction; insert into user values(5,’c’,100); commit;Query OK, 0 rows affected (0.00 sec) Query OK, 1 row affected (0.01 sec)Query OK, 0 rows affected (0.01 sec) mysql&gt; select * from user;+—-+——–+——-+| id | name | money |+—-+——–+——-+| 1 | a | 980 || 2 | b | 1020 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 || 5 | c | 100 |+—-+——–+——-+5 rows in set (0.04 sec) 小张上完厕所抽完烟回来了，小王没有commit的时候，小张执行select * from user； mysql&gt; select * from user;+—-+———–+——-+| id | name | money |+—-+———–+——-+| 1 | a | 980 || 2 | b | 1020 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 || 5 | c | 100 |+—-+———–+——-+5 rows in set (0.00 sec) 但是执行select avg(money) from user; mysql&gt; select avg(money) from user;+————+| avg(money) |+————+| 820.0000 |+————+1 row in set (0.07 sec) money的平均值不是1000，变少了 虽然我只能读到另一个事务提交的数据，但是还是会出现问题，就是读取同一个表的数据，发现前后不一致，这种不可重复读现象，read committed 3.repeatable read; 可以重复读123set global transaction isolation level repeatable read;select @@global.transaction_isolation; mysql&gt; set global transaction isolation level repeatable read; select @@global.transaction_isolation; Query OK, 0 rows affected (0.00 sec) +——————————–+| @@global.transaction_isolation |+——————————–+| REPEATABLE-READ |+——————————–+1 row in set (0.03 sec) 张全蛋 start transaction; insert into user values(6,’d’,1000); 张全蛋可以查到6号信息 王尼玛： start transaction; 王尼玛查不到6号信息 但是王尼玛不能插入6号，会报错 这种现象叫做幻读 事务a和事务b同时操作一张表，事务a提交的数据，也不能读到，就可能造成幻读 serializable:串行化123set global transaction isolation level serializable;select @@global.transaction_isolation; 还是张全蛋和王尼玛，做了和上面一样的事 当user表被另外一个事务操作的时候，其他的事务是不可以执行的，进入排队状态，直到操作事务的那个人commit之后，才会执行 串行化commit之后，其他事务立刻执行，但时间长了，可能会失效 串行化问题：性能特差 read uncommitted &gt;read commited&gt;repeatable read&gt;serializable 隔离级别越高，性能越差 mysql默认隔离级别事 peteatable read]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql_select]]></title>
    <url>%2F2019%2F08%2F16%2Fmysql%2Fselect%2F</url>
    <content type="text"><![CDATA[子查询 select特殊功能：distinct(排重)：select distinct 字段名 from 数据表; between…and：select * from 数据表 where 字段名 between 值 and 值; 相当于select * from 数据表 where 字段名&gt;字段值 and 字段名&lt;字段值; in：select * from 数据表 where 字段名 in(85，86，87); or：select * from 数据表 where 字段名1 = ‘值’ or 字段名2 = ‘值’;(升序查询 asc从小到大)select * from 数据表 order by 字段名 asc; order by：系统默认是升序 desc降序（从大到小） count(统计)：select count(*) from 数据表 where 字段名 = 值; (聚合函数) avg(平均)：select avg(字段名) from 数据表 where 字段名 = 值;(聚合函数) as：起别名 like(%)：模糊查询 %代表任意字段 not like：模糊查询相反 order by(降序查询 desc从大到小)：select * from 数据表 order by 字段名 desc; group by：需要和 聚合函数（例如：max（），count（），avg（）等）配合使用，使用时至少有一个分组标识字段（例如某一列的列名），分组标识的字段如果有多个相同的，那么搜索结果中只会出现第一次查到的这个字段的记录的信息，可以通过having having(分组条件)：作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。 可以包含聚集函数，但是where不能包含聚集函数 year(sbirthday)：查询出生年份 year(now())：查看当前年份 union：把两个查询的结果连接起来 any：字段中 任意的某条记录 all：字段中 所有的记录 count(*)：函数返回由select语句返回的结果集中的行数 max(字段名)：字段中的最大值 min(字段名)：字段中的最小值 查询字段中的最大最小： 一：（子查询） select * from 数据表 where 字段名 = (select max(字段名) from 数据表); 1.找到最高分：select max(字段名) from 数据表; 2.根据最高分查询考生信息：select * from 数据表 where 字段名 = (select max(字段名) from 数据表); 二：（排序） select * from 数据表 order by 字段名 desc limit 0,1; limit：第一个数字是从多少条开始，第二个数字是查多少条 这个是降序，限制获得第一条，第一条就是最大的，获得最大值 注意：排序有缺陷，如果最大值有两条，她只能查到一条 查询score表中至少有两名学生选修的并以3开头的课程的平均分数 having(分组条件)：having字句可以让我们筛选成组后的各种数据，where字句在聚合前先筛选记录，也就是说作用在group by和having字句前。而 having子句在聚合后对组记录进行筛选。 1select cno from score group by cno having count(cno)&gt;=2 and cno like '3%'; %代表的是任意的东西 3%代表以3开头的任意东西 多表查询：精髓：他们是根据相等的地方进行联系的 两张表： 查询当条件相同时，把数据替换掉 1select sname,cno,degree from student,score where student.sno = score.sno; 三张表： 12select sname,cname,degree from student,course,score where student.sno = score.sno and course.cno = score.cno; 子查询：精髓：分开步骤去查 查一个班的学生： 1select * from student where class = '95031'; 查学生的分数： 1select * from score where class = '95031'; 查一个班学生的平均成绩： 1select cno,avg(degree) from score where sno in (select sno from student where class = '95031') group by cno; 查询选修3-105课程成绩高于109号同学3-105成绩的所有同学的记录 1select * from score where cno='3-105' and degree&gt;(select degree from score where sno='109' and cno='3-105'); 查询成绩高于学号为109、课程号为3-105的成绩的记录 1select * from* score where degree&gt;(select degree from score where sno='109' and cno='3-105'); 查询与学号为108和101的同学同年出生的所有学生 查询学号为108和101的学生： 1select * from student where sno in(108,101); 查询学号为108和101学生的出生年份： 1select &lt;u&gt;*year(sbirthday)*&lt;/u&gt; from student where sno in(108,101); 1select * from student where year(sbirthday) in(select year(sbirthday) from student where sno in(108,101)); 查询张旭教师任课的学生成绩： 教师表中查询tno：select tno from teacher where tname=’张旭’; 查询他任的课cno： 1select cno from cource where tno=(select tno from teacher where tname='张旭'); 1select * from score where cno in(select cno from cource where tno=(select tno from teacher where tname='张旭')); 查询某课程的同学数多余5人的教师姓名： 课程数大于五的cno：select cno from score group by cno having count(*)&gt;5; 查询tno： 1select tno from course where cno in(select cno from score group by cno having count(*)&gt;5); 1select tname from teacher where tno in(select tno from course where cno=(select cno from score group by cno having count(*)&gt;5)); 查看计算机系和电子工程系不同职称的教师的tname和pref 1select prof from teacher where depart = '电子工程系' and prof not in(select * from teacher where depart = '计算机系') union 1select * from teacher where depart = '计算机系' and prof not in(select prof from teacher where depart = '电子工程系' ); 查询选修学号为3-105课程且成绩至少高于选修编号3-245的同学的Cno、Sno和Degree，并按Degree从高到底依次排序 1234select cno,sno,degree from score where cno='3-105'and degree&gt;&lt;u&gt;**any**&lt;/u&gt;(select degree from score where cno='3-245') order by degree desc; //从高到低 复制表数据做条件查询： 1select * from score a where degree&lt;(select avg(degree) from score b where a.cno=b.cno); 查询至少有两名男生的班级： 1select class from student where ssex = '男' group by class having count(*) &gt; 1; 按等级查询： 1select sno,cno,grade from score,grade where degree between low and upp; sql的四种链接查询：内链接： inner join 或者 join 外连接： 1.左连接：left join 或者 left outer join 2.右连接：right join 或者 right outer join 3.完全外连接：full join 或者 full outer join person表：id，name，cardId card表：id，name person表中的cardId来自于card表中的id create table person( ​ id int, ​ name varchar(20), ​ cardId int ); create table card( ​ id int, ​ name varchar(20) ); insert into card values(1,’饭卡’); insert into card values(2,’建行卡’); insert into card values(3,’农行卡’); insert into card values(4,’工商卡’); insert into card values(5,’邮政卡’); insert into person values(1,’张三’,1); insert into person values(2,’李四’,3); insert into person values(3,’王五’,6); 并没有创建外键，如果创建的话person里面的第三条数据插不进去 inner join查询：(内连接) 1select * from person p inner join card c on p.cardId = c.id; 1select * from person p, card c where c.id = p.cardId; 内联查询：其实就是相当于把两个表里面的数据，通过某个字段相对应，把有关系的数据查询出来 mysql&gt; select * from person p, card c where c.id = p.cardId;+—-+——+——–+—-+——–+| id | name | cardId | id | name |+—-+——+——–+—-+——–+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 |+—-+——+——–+—-+——–+ left join:（左外连接)outer 1select * from person left join card on person.cardId = card.id; 左外连接：会把左边表里的数据全部取出来，而右边表里的数据有就显示出来，没有就会变成NULL mysql&gt; select * from person left join card on person.cardId = card.id;+—-+——+——–+——+——–+| id | name | cardId | id | name |+—-+——+——–+——+——–+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || 3 | 王五 | 6 | NULL | NULL |+—-+——+——–+——+——–+ right join：(右外连接)outer 1select * from person right join card on person.cardId = card.id; 左外连接：会把右边表里的数据全部取出来，而左边表里的数据有就显示出来，没有就会变成NULL mysql&gt; select * from person right join card on person.cardId = card.id;+——+——+——–+—-+——–+| id | name | cardId | id | name |+——+——+——–+—-+——–+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || NULL | NULL | NULL | 2 | 建行卡 || NULL | NULL | NULL | 4 | 工商卡 || NULL | NULL | NULL | 5 | 邮政卡 |+——+——+——–+—-+——–+ full join：（全外连接） 1select * from person full join card on person.cardId = card.id; mysql&gt; select * from person full join card on person.cardId = card.id;1054 - Unknown column ‘person.cardId’ in ‘on clause’ 原因是mysql不支持full join 全外连接我们想要的结果： 123select * from person left join card on person.cardId = card.id union select * from person right join card on person.cardId = card.id; +——+——+——–+——+——–+| id | name | cardId | id | name |+——+——+——–+——+——–+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || 3 | 王五 | 6 | NULL | NULL || NULL | NULL | NULL | 2 | 建行卡 || NULL | NULL | NULL | 4 | 工商卡 || NULL | NULL | NULL | 5 | 邮政卡 |+——+——+——–+——+——–+ 连接的好处：可以不创建外键]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis_start]]></title>
    <url>%2F2019%2F08%2F14%2Fmybatis%2Fstart%2F</url>
    <content type="text"><![CDATA[mybatis使用不同方法进行增删改查 对原生态jdbc程序问题的总结（单独使用jdbc开发） 数据库用的时候连接，不用的时候释放，频繁操作 通过连接池节约资源 sql语句硬编码，不利于系统维护 使用配置文件把他配起来 mybatis框架原理特点mybatis是持久层框架，是apache下的项目 mybatis让程序主要精力放在sql上，通过mybatis提供的映射方式，简化sql mybatis将输入参数自动进行输入映射，将查询结果集映射成java对象 mybatis框架先完成基本配置： SqlMapConfig.xml：是mybatis的全局配置文件（名称不固定）。配置了数据源（c3p0）、事务（spring）等mybatis运行环境。配置里有个特别的东西（mapper.xml）这个文件里是映射关系（配置sql语句）通过配置文件生成会话工厂（SqlSessionFactory） 操作数据库： SqlSessionFactory（会话工厂）创建 -&gt;SqlSession（接口）：会话 作用：操作数据库（发出sql增删改查）内部通过执行器（Excutor接口）操作数据库,两种实现方式（基本执行器、缓存执行器）。 这个执行器需要很多参数，所以mybatis提供了一个底层的封装对象（mapped statement）作用：对数据库存储封装，包括sql语句，输入参数，输出结果类型，终于连接上了数据库 输入参数类型：pojo、java简单类型、hashmap 输出结果类型：pojo、java简单类型、hashmap mybatis入门程序增删改查lib下的一般是依赖包 查询用户信息根据用户名称模糊查询用户信息 首先在映射文件中配置sql语句 映射：（hibernate：orm：对象关系映射，实体类和数据表映射）咱们的xml映射分为输入映射、输出映射 映射文件名 :user.xml(ibatis)、xxxMapper.xml(mybatis) namespace命名空间，sql的隔离 映射文件中的sql语句会封装到mapped statement对象中 在SqlMapConfig.xml中加载刚刚写好的xxxMapper.xml 123&lt;mappers&gt; &lt;mapper resource="路径/xxxMapper.xml"&gt;&lt;/mappers&gt; 程序编写，创建会话工厂，连接数据库 12345678910111213141516171819202122232425262728293031//mybatis配置文件String resource = "sqlmap/SqlMapConfig.xml";得到配置文件的流Resource.getResourceAsStream(resource);//创建会话工厂传入mybatis的配置文件信息，需要一个配置文件流SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);//通过工厂得到会话SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();//通过SqlSession操作数据库//第一个参数：映射文件中的statement的id，等于=namespace+"."+statement的id//第二个参数：指定和映射文件中所匹配的parameterType类型的参数User user = sqlSession.selectOne(statement,parameter);//提交事务sqlSession.commit();//释放资源sqlSession.close(); sql语句的格式id：标识映射文件中的sql 将sql语句封装到mapped statement 对象中，所以id称为statement的id parameterType：指定输入参数的类型 #{}表示一个占位符号 ${}表示一个拼接符号，会引起sql注入（拼接的时候写where 1=1） #{id}：其中的id表示接入输入的参数，参数名称就是id，如果输入参数是简单类型，#{}中的参数名可以任意，可以实value或其他的名称都行 resultType：指定输出结果的类型，表示将单条记录映射成java对象 selectOne表示查询出1条记录进行映射 selectList表示查询出一个列表（多条记录）进行映射 添加用户parameterType：指定输入参数类型是pojo（包括用户信息） #{}中指定的pojo的属性名，接收到pojo对象的属性值OGNL获取对象的属性值 sql后面不要加; 自增主键返回：执行insert提交之前自动生成一个自增主键。通过mysql函数获取到刚插入记录的自增主键（select last_insert_idid();）在inseert之后调用 1234567891011121314151617&lt;insert id = "insertUser" parameterType = "cn.itcast.mybatis.po.User"&gt;&lt;!--keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性order：select last_insert_id()执行顺序，相对于insert语句来说他的执行顺序resultType:指定select last_insert_id()结果的类型--&gt;&lt;selectKey keyProperty="id" order="after" resultType="java.lang.Integer"&gt; select last_insert_id();&lt;/selectKey&gt;insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;adress&#125;)&lt;/insert&gt; 非自增主键的返回： mysql的uuid()函数生成主键，需要修改id字段类型的为String，长度设置为35位 执行思路：先通过uuid();查询到主键，将主键注入到sql语句中，执行uuid();语句顺序相对于insert语句之前执行 删除用户sqlSession.update(statement,parameter); sqlSession.delete(statement,parameter); sqlSession.selectOne/List(statement,parameter); sqlSession.insert(statement,parameter); 更新用户入门程序的总结#{}表示一个占位符，接受输入参数，类型可以是简单类型、pojo、hashmap，如果接受简单类型，#{}中可以写成value或其他名称 #{}接受pojo对象值，通过OGNL读取对象的属性值，通过属性.属性.属性…的方式获取属性值 ${}表示一个拼接符，会出现sql注入，不建议使用。接受输入参数，类型可以是简单类型、pojo、hashmap，如果接受简单类型，#{}中只能写成value ${}接受pojo对象值，通过OGNL读取对象的属性值，通过属性.属性.属性…的方式获取属性值 mybatis和hibernate本质区别和应用场景hibernate：入门门槛较高，是一个标准的ORM框架（对象关系映射），不需要程序员写sql，sql语句自动生成。对sql语句的优化、修改比较困难 应用场景：适应于需求变化较少的中小型的项目，比如：后台管理系统，erp、orm、oa… mybatis：专注于sql本身，需要程序员自己编写sql语句，sql修改、优化比较方便。mybatis是一个不完全的ORM框架，虽然程序员自己写sql，但是存在映射（输入映射、输出映射） 应用场景：适应于需求项目较多的项目，比如：互联网项目 企业进行技术选型，以低成本、高回报作为技术选型的原则，根据项目组的项目力量进行选择 mybatis开发dao的两种方法SqlSession使用范围（单例）通过SqlSessionFactoryBuilder创建SqlSessionFactory，将SqlSessionFactoryBuilder当成一个工具类即可，不需要使用单例管理SqlSessionFactoryBuilder。在需要创建工厂的时候只需要创建一次SqlSessionFactoryBuilder即可（因为下面的SqlSessionFactory是单例管理的） 通过SqlSessionFactory创建SqlSession，通过使用单例模式管理sqlSessionFactory（工厂一旦创建，就一直使用一个实例） 将来mybatis和spring整合后，使用单例模式管理sqlSessionFactory SqlSession：是一个面向用户（程序员）的接口提供了很多操作数据库的方法：如：selectOne、selectList。是线程不安全的，在SqlSession的实现类中，除了有接口中的方法（操作数据库的方法）、还有数据域的属性（多例不安全）。SqlSession最佳的应用场合在方法体内，定义成局部变量 原始dao开发方法思路需要编写dao接口和dao实现类 需要向dao实现类中注入SqlSessionFactory，在方法体中通过SqlSessionFactory常见SqlSession dao接口dao接口实现类1234567891011//需要向dao实现类中注入SqlSessionFactory这里通过构造方法注入private SqlSessionFactory sqlSessionFactory;public 类名 (SqlSessionFactory sqlSessionFactory)&#123;this.sqlSessionFactory = sqlSessionFactory;&#125; @Befor是在测试类之前执行的类：需要创建会话工厂，供测试类通过构造器注入 @Text是测试类：创建UserDao这个实现类的时候，UserDaoImpl构造器需要一个sqlSessionFactory，有@Befor提供；创建成功后可以开始调用UserDao里面的方法 总结原始dao开发的问题1.dao接口的实现类的方法中存在大量的模板方法，设想能否将这些代码提取出来，大大减轻程序员的工作量 2.第一个参数：看这个蓝色的地方：是个硬编码（statement的id硬编码） 3.第二个参数的类型是泛型，即使传入参数错误，在编译阶段也不报错，不利于程序员开发 mybatis的mapper代理的开发方法程序员编写mapper.xml映射文件 程序员编写mapper接口（相当于dao接口）需要遵循一些开发规范，mybatis可以自动生成mapper接口实现类代理对象。 mybatis可以自动生成mapper接口实现类的代理对象 开发规范1.在mapper.xml中namespace等于mapper接口的地址 2.mapper.java接口中的方法名，和mapper.xml中的statement的id一致 3.mapper.java接口中的方法输入参数类型和mapper.xml中statement中的statement的parameterType指定的类型一致 4.mapper.java中的返回值类型和mapper.xml中的statement中的resultType指定的类型一致 总结以上的开发规范主要是对下边的代码进行统一的生成 namespace变成了mapper.java的路径，mapper.java中的方法名是mapper.xml的staement的id，mybatis会自动拼接这两个东西生成原始Dao开发的第一个参数，第二个参数由第三条和第四条规范实现了 12345678910111213User user = sqlSession.selectOne("namespace+statement的id",占位符对应的输入参数);sqlSession.insert("",);//开启会话，无论是什么开发，都得开启会话SqlSession sqlSession = sqlSessionFactory.openSession();//创建UserMapper对象,mybatis自动生成mapper代理对象UserMapper userMapper = sqlSession.getMapper(UserMapper.class);调用userMapper的方法 注意：要在SqlMapConfig.xml中加载mapper.xml 问题总结代理对象内部调用selectOne或selectList如果mapper方法返回单个pojo对象（非集合对象），代理对象的内部通过selectOne查询数据库 如果mapper方法返回对象集合，代理对象内部通过selectList查询数据库 mapper接口方法的参数个数mapper接口方法的参数个数只能有一个，系统是否不利于系统维护 系统框架中，dao层的代码是被业务层共用的，即使mapper接口只有一个参数，可以使用包装类型的pojo瞒住不同业务方法的参数 注意：持久层中方法的参数可以用包装类型、map等，但是service方法中建议不要使用包装类型（不利于业务层的可扩展性） ***Mapper代理开发和dao原始开发总结原始开发：映射文件中的sql语句会封装到mapped statement对象中 在SqlMapConfig.xml中加载刚刚写好的xxxMapper.xml 12345&lt;mappers&gt; ​ &lt;mapper resource="路径/xxxMapper.xml"&gt;&lt;/mappers&gt; 程序编写，创建会话工厂，连接数据库 12345678910111213141516171819202122232425262728293031//mybatis配置文件String resource = "sqlmap/SqlMapConfig.xml";得到配置文件的流Resource.getResourceAsStream(resource);//创建会话工厂传入mybatis的配置文件信息，需要一个配置文件流SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);//通过工厂得到会话SqlSession，这个不论是怎么开发都必须有的SqlSession sqlSession = sqlSessionFactory.openSession();//通过SqlSession操作数据库//第一个参数：映射文件中的statement的id，等于=namespace+"."+statement的id//第二个参数：指定和映射文件中所匹配的parameterType类型的参数这里有缺陷User user = sqlSession.selectOne(statement,parameter);//提交事务sqlSession.commit();//释放资源sqlSession.close(); 自己配置SqlMapConfig.xml 和 mapper.xml 通过配置文件生成会话工厂（SqlSessionFactory） 通过会话工厂生成会话（SqlSession） 通过SqlSession操作数据库 开发的流程： 编写写sql的xml，在mybatis全局配置的xml中加载编写sql的xml 编写sql的xml里的namespace对应mapper.java的类的全路径，里面的sql的id对应类中的方法名（原始开发的第一个参数statementid）。mapper.java里面的方法入参和出参对应原始dao开发的第二个参数 mapper代理开发开发规范1.在mapper.xml中namespace等于mapper接口的地址 2.mapper.java接口中的方法名，和mapper.xml中的statement的id一致 3.mapper.java接口中的方法输入参数类型和mapper.xml中statement中的statement的parameterType指定的类型一致 4.mapper.java中的返回值类型和mapper.xml中的statement中的resultType指定的类型一致 在原始开发中添加了开发规范，这些开发规范的作用： 12345//第一个参数：映射文件中的statement的id，等于=namespace+"."+statement的id//第二个参数：指定和映射文件中所匹配的parameterType类型的参数这里有缺陷，第二个参数是泛型User user = sqlSession.selectOne(statement,parameter); 第一条和第二条开发规范优化了SqlSession的第一个参数，系统可以自动拼接，不需要我们去传入了 第三条和第四条开发规范优化了SqlSession的第二个参数，可以判断他的parameterType和resultType，而不是原始开发中的泛型 mybatis的配置文件SqlMapConfig.xmlmybatis的全局配置文件SqlMapConifig.xml，配置内容如下： properties（属性)、setting（全局配置参数）、typeAliases（类型别名）、typeHandlers（类型处理器）、objectFactory（对象工厂）、plugins（插件）、environments（环境集合属性对象）（environment（环境子属性对象（transactionManager（事务管理）、dataSource（数据源））））、mappers（映射器） properties需求： 将数据库连接的参数单独配置在db.properties中，只需要在SqlMapConfig.xml中加载db.properties的属性值（添加了一个配置文件），这样做的话，在SqlMapConfig.xml中就不需要对数据库的连接参数进行硬编码。 将数据库连接参数只配置在db.properties中的原因：方便对参数的统一管理，其他的xml可以引用改db.properties 1234567891011&lt;!--SqlMapConfig.xml加载属性文件（db.properties）--&gt;&lt;properties resource = "db.properties"&gt;&lt;/properties&gt;&lt;!--配置数据库连接池--&gt;&lt;dataSource&gt;​ &lt;property name = "driver" value = "$&#123;文件中的属性名称&#125;" /&gt;&lt;/dataSource&gt; properties特性： mybatis将按照下面的顺序来加载属性： 1.在properties元素体内定义属性首先被读取 2.然后会读取properties元素中resource或url加载的属性，他会覆盖已读取的同名属性 3.最后读取parameterType传递的属性，他会覆盖已读取的同名属性 因此，通过parameterType传递的属性具有最高优先级，resource或url加载的属性次之，最低优先级是properties元素体内定义的属性 建议：不要再properties元素体内添加任何属性值，只将属性值定义在properties文件中，在properties文件中定义属性名要有一定的特殊性，如xxx.xxx settings全局参数配置mybatis运行时可以调整一些运行参数 比如：开启二级缓存，开启延迟加载 这些参数会影响mybatis的运行行为，如果操作不当，可能会导致运行出现问题 typeAliases（别名）需求： 在mapper.xml中，定义很多的statement，statement需要parameterType指定输入参数类型、需要resultType指定输出结果的映射类型 如果在指定类型的时候输入类型全路径，不方便进行开发，可以针对parameterType或ResultType指定的类型定义一些别名，在mapper.xml中通过别名定义，方便开发 mybatis有一些自己默认的别名，但是对于pojo需要自己定义别名 12345678910111213&lt;typeAliases&gt;​ //单个别名的定义​ &lt;typeAlias type = "全路径名（pojo类的路径）" alias = "别名" /&gt;​ //批量别名的定义​ 指定包名，mybatis自动扫描包中的po类，别名就是类名（首字母大小写都可以）​ &lt;package name = "包名"/&gt;&lt;/typeAliases&gt; typeHandlers（类型处理器）mybatis中通过typeHandlers完成jdbc类型和java类型的转换 通常情况下，mybatis提供的处理器满足日常需要，不需要自定义 mappers（映射配置）通过resource加载单个文件 123456789&lt;maper class/resource/url/ /&gt;&lt;!--通过mapper接口加载映射文件，需要将mapper接口的类名和mapper.xml映射文件的名称保持一致，且在一个目录，上边规范的前提是使用mapper代理的方法--&gt;&lt;maper class /&gt;指定的不是映射文件，指定的是class//批量加载mapper,指定mapper接口的包名，mybatis自动扫描包下的所有接口进行加载。这个遵循上面的规范&lt;package name = "" /&gt; 输入映射通过parameterType指定输入参数类型，类型可以实简单类型、hashmap、pojo的包装类型 传递pojo的包装对象： 需求：完成用户信息的综合查询，需要传入查询条件很复杂（可能包含用户信息、其他信息，比如商品、订单的） 针对上面的需求建议使用自定义的pojo，自定义查询条件 输出映射resultType: 使用resultType进行输出映射，只有查询出来的列名和pojo的属性名一致，该列才可以映射成功。如果查询出来的列名和pojo中的属性名全部不一致，没有创建pojo对象。只要查询出来的列名和pojo中的属性有一个一致，就会创建一个pojo对象 输出简单类型：用户信息的综合查询的列表总数，通过查询总数和上边用户综合查询列表才可以实现分页 小节：只有查询出来的只有一行且有一列才可以使用输出简单类型 输出pojo对象和pojo列表：不管输出的是pojo对象还是列表，在mapper.xml中resultType中指定的类型是一样的，但是在mapper.java中的返回值类型不一样（对象、集合），然后自动生成的mapper代理对象中是根据mapper方法的返回值类型确定是调用selectOne还是selectList resultMap： mybatis中使用resultMap完成高级输出结果映射 使用方法： 如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间做一个映射关系 1.定义resultMap 123456789//id是resultMAp的唯一标识&lt;resultMap type = "" id = ""&gt;​ //id表示查询结果的唯一标识 ，column sql语句中查询的列名，property：pojo中的属性名​ &lt;id column = "" property = ""/&gt;&lt;/resultMap&gt; resultMap：给定义的resultMap的id，如果这个resultMap在其他的mapper文档中，前边需要加namespace 2.使用resultMap作为statement的输出映射类型 将下边的sql用UserCostom完成映射 userCustom类中的属性和上边的查询列名不一致 小节： 使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功，如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系 动态sql什么是动态sqlmybatis核心：对sql语句进行灵活的操作，通过表达式，对sql进行灵活判断，组装 需求： 用户信息的综合查询列表和用户信息查询列表的总数 这两个statement的定义使用动态sql。对查询条件进行判断，查询条件不为空，我们才会对查询语句进行拼接 if1234567//可以去掉查询条件中的第一个and&lt;where&gt;&lt;/where&gt;//判断条件&lt;if test = "条件"&gt;sql语句&lt;/if&gt; foreach向sql传递数组或list，mybatis使用foreach解析 在用户查询列表和查询总数的statement中添加多个id输入查询 在输入参数类型中添加list ids传入多个id 12345//使用foreach遍历传入的ids//collections：指定输入对象中集合属性，item：每次遍历生成对象中的属性名，open：开始遍历时拼接的串，close：结束遍历时拼接串,separator:遍历的两个对象中间需要拼接的串&lt;foreach collections = "" item = "" open = "AND(" close = ")" separator = ""&gt;id = #&#123;这里填的时item里面填的东西&#125;&lt;/foreach&gt; sql片段需求: 将上边实现的sql判断代码抽取出来，组成一个sql片段。其他的statement中就可以来引用这个sql片段 在mapper.xml中定义的statement的引用sql片段 1.定义sql 1234567//sql片段的唯一标识,一般我们定义sql片段是基于单表来定义的，这样的话可重用性高。在sql片段中不要包括where&lt;sql id = ""&gt;​ &lt;if test = "条件"&gt;sql语句&lt;/if&gt;&lt;/sql&gt; 2.引用sql 123456789//引用sql片段的id，如果refid指定的id不再本mapper文件中，需要在前面加namespace&lt;where&gt;​ &lt;include refid = ""&gt;&lt;/include&gt;​ //在这里还要引用其他的sql片段，所以sql片段不能加where&lt;/where&gt;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis_high]]></title>
    <url>%2F2019%2F08%2F14%2Fmybatis%2Fhigh%2F</url>
    <content type="text"><![CDATA[mybatis高级映射及开发方法 课程复习： mybatis是什么？mybatis和hibernate都是持久层框架，mybatis是一个不完全的ORM框架，sql语句需要程序员自己去编写，但mybatis也有映射（输入映射、输出映射） mybatis入门门槛不高，学习成本低，让程序员把精力放在sql语句上，对sql语句优化非常方便，适用于需求变化较多的项目，比如互联网项目 mybatis框架执行过程： 1.配置mybatis的配置文件，SqlMapConfig（名称不固定） 2.通过配置文件，加载mybatis运行环境，创建SqlSessionFactory会话工厂。SqlSessionFactory实际使用时按单列管理 3.通过工厂创建SqlSession SqlSession是一个面向用户的接口（提供操作数据库的方法），实现对象是线程不安全的，建议SqlSession应用场合在方法体内 4.调用SqlSession的方法去操作数据库 如果需要提交事务，需要执行SqlSession的commit()方法 5.释放资源，关闭SqlSession mybatis开发dao的方法： 1.原始dao方法：需要程序员编写dao接口和实现类。需要在dao实现类中注入一个SqlSessionFactory工厂 2.mapper代理开发方法： 只需要程序员编写mapper接口（就是dao接口） 程序员在编写mapper.xml（映射文件）和mapper.java需要遵循一个开发规范 a.在mapper.xml中namespace就是mapper.java的全路径 b.mapper.xml中statement的id和mapper.java中的方法名一致 c.mapper.xml中statement的parameterType指定的参数类型和mapper.java中方法的输入参数类型一致 d.mapper.xml中statement的resultType指定的参数类型和mapper.java中方法的输出参数类型一致 输入映射 parameterType：指定输入参数的类型可以是简单类型、pojo、hashmap，对于综合查询，建议parameterType使用包装的pojo，有利于系统扩展 输出映射 resultType：查询道德列名和resultType指定的属性名一致，才能映射成功 resultMap：可以通过resultMap来完成高级的映射、复杂的映射，如果查询道德列名和pojo的属性不一致时，我们就可以通过resultMap来设置列名和属性名之间的映射关系。可以完成映射 高级映射 将关联查询的列映射到pojo的属性中（一对一） 将关联查询的列映射到List中（一对多） 动态sql if、where、foreach、sql片段 订单商品数据模型分析数据模型分析思路1.每张表记录的数据内容：分模块对每张表的内容进行熟悉，相当于你学习系统需求（功能）的过程 2.每张表重要数据字段设置：非空字段、有外键的字段 3.数据库级别表与表之间的关系：外键关系 4.表与表之间的业务关系：在分析表与表之间的业务关系时一定是建立在某个业务意义基础上去分析 先分析数据级别之间有关系的表之间的业务关系： user和orders： user—&gt;orders：一个用户可以创建多个订单，一对多 orders—&gt;user：一个订单可以由多个用户创建，一对一 orders和orderdetall： orders—&gt;orderdetall：一个订单包含多个订单明细，一个订单可以购买多个商品，每个商品的购买信息都在orderdetail记录，一对多关系 orderdetall—&gt;orders：一个订单明细只能包括在一个订单中，一对一 高级结果映射一对一 查询订单信息，关联查询创建订单用户信息 slq语句：查询订单信息，关联查询创建订单用户 resultType： 创建一个pojo让他字段名和属性名一一对应 创建的时候可以让他继承一下之前的pojo类，这样可以简化后台代码 resultMap： 使用resultMap将查询结果映射到Order对象中，在orders类中添加user属性，将关联查询出来的用户信息映射到orders对象中的user属性中 1&#123;% asset_img 1565493794869.png This is an image %&#125; 实体类orders里面的实体类user association里面的标签是配置查询的列和user实体类对应的信息 id：关联查询用户的唯一标识 javaType：需要映射的那个实体类的路径（user） column：指定用户信息的列 property：user中的属性名 resultType和resultMap 实现一对一查询： resultType：使用resultType实现较为简单，如果pojo中没有包括查询的列名，需要增加与列名对应的属性，即可完成映射 如果没有查询结果的特殊要求建议使用resultType resultMap：需要定义resultMap，实现有点复杂，如果对查询结果由特殊要求，使用resultMap可以完成将关联查询映射pojo的属性中 resulrMap可以实现延迟加载，而resultType无法实现延迟加载 一对多 查询订单及订单明细 sql语句：确定主查询表、确定关联查询表 collection：一个订单关联出了多条明细，要使用collection进行映射。collection：对关联查询道德多条记录映射到集合对象中 property：将关联查询到的多条记录映射到集合对象的哪个属性中 ofType：集合对象的一条pojo对应的实体类的路径 小结 mybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性中 使用resultType实现：将订单明细映射到orders中的orderdetails中需要自己处理，使用双重循环遍历，去掉重复记录，将订单明细放在orderdetails 多对多 总结： 将查询用户购买商品信息明细清单（用户名、用户地址、购买商品时间、购买商品数量） 针对上边的需求，将查询到的记录映射到扩展的pojo中，很简单实现明细清单的功能 使用resultMap对查询结果映射有特殊要求的功能 mybatis延迟加载 使用association中的select指定延迟加载去执行statement的id 延迟加载是什么？先执行简单查询语句，有条件的话，利用association来执行副表查询语句。减轻数据库的压力 不适用mybatis提供的association及collection中的延迟加载功能，如何实现延迟加载 实现方法如下：先去查询一个mapper方法，获取第一个mapper查询的订单信息。在程序中，按需去调用第二个mapper方法去查询用户信息 使用延迟加载是为了，先查询简单的sql，再去按需加载关联查询的其他信息 mybatis查询缓存一级缓存：sqlSession级别的缓存，在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMAp）用于存储数据。不同的sqlSession之间缓存数据区域（HashMap）是互相不影响的 二级缓存：mapper级别的缓存：多个sqlSession去操作同一个Mapper的sql语句，多个sqlSession可以共用二级缓存，二级缓存可以跨sqlSession的 为什么要用缓存？ 如果存储中有数据就不用从数据库中获取，大大提高系统性能 一级缓存第一次发起查询用户id位1的用户信息，先去缓存中查询是否有id为1的用户信息，如果没有，从数据库查询用户信息 得到用户信息，将用户信息存储到一级缓存中 第二次发起查询用户id位1的用户信息，先去缓存中查询是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息 如果sqlSession去执行commit操作（去执行、更新、删除），清空sqlSession中的一级缓存，这样做的目的是为了让缓存中的信息存储的是最新的信息，避免脏读 mybatis默认支持一级缓存，不需要在配置文件中去开启缓存 一级缓存的应用正式开发：是将spring和mybatis进行整合开发，事务控制在service中 一个service方法中包括很多mapper方法调用 service： 开始执行时，开启事务，创建sqlSession对象 第一次调用mapper的方法。 第二次调用mapper的方法，从一级缓存中拿数据 方法结束，sqlSession关闭 如果执行两次service调用查询相同的用户信息，不走一级缓存，因为session方法结束，sqlSession就关闭，一级缓存就清空 这样的话，我们就需要学习二级缓存 二级缓存首先要手动开启mybatis的二级缓存 sqlSession1去查询用户id为1的用户信息，查询到用户信息会将查询数据存储到二级缓存中 sqlSession2去查询用户id为1的用户信息，先去缓存中查找是否存在数据，如果存在直接从缓存中取出数据。 如果执行了commit的话，那么就会清空mapper对应的二级缓存下的数据 二级缓存和一级缓存的区别，二级缓存的范围更大，多个sqlSession可以共享一个UserMapper的二级缓存区域。UserMapper有一个二级缓存区域，其他的Mapper也有缓存区域（按照namespace分的）。也就是说每一个namespace的mapper有一个二级缓存区域，两个mapper的namespace如果相同，那么这两个mapper执行sql查询到的数据将存储在相同的二级缓存区域中 开启二级缓存mybatis的二级缓存是mapper范围级别，除了在SqlMapConfig.xml设置二级缓存的总开关，还要再具体的mapper.xml中开启二级缓存 在UserMapper.xml中开启二级缓存，UserMapper.xml下的sql执行完成后会存储到他的缓存区域（HashMap） 开启本Mapper namespace下的二级缓存： 调用pojo类实现序列化接口：为了将缓存数据取出执行反序化操作，因为二级缓存数据介质多种多样，不一定在内存 禁用二级缓存1&lt;select userCatch = "false"&gt; 这样配置的话，这条语句每次都会去数据库查询，禁用二级缓存。针对每次查询都需要最新的数据sql 总结一般情况下，执行完commit操作都需要刷新缓存，flushCache = “true”代表刷新缓存，这样可以避免数据库脏读 刷新缓存刷新缓存是清空缓存，在mapper的同一个namespace中，如果有其他insert、update、delete操作后需要刷新缓存，如果不刷新缓存就会出现脏读 设置statement配置中的flushCache = “true”属性，默认情况下为true即刷新缓存，如果改成false则不会刷新。使用缓存时会出现脏读,如下： 1&lt;insert id = "insertUser" parameterType = "User" flushCache = "true"&gt; mybatis整合ehcacheehcache是一个分布式缓存框架 分布缓存我们的系统为了提高系统并发、性能，一般对系统进行分布式部署（集群部署方式） 不使用分布缓存，缓存的数据在各个服务单独存储，不方便开发。所以要使用分布式缓存对缓存数据进行集中管理 对缓存数据集中管理，我们要使用分布式缓存框架redis、memcached、ehcache mybatis无法实现分布式缓存，不利于系统开发，需要和其他的分布式缓存框架进行整合 整合的方法mybatis提供了一个cache接口，如果要实现自己的缓存逻辑，实现自己的cache接口即可 mybatis和ehcache整合，mybatis和ehcache整合包中提供了一个cache接口的实现类 mybatis有默认实现的cache类 整合eacache： 1.导入包 2.实现cache类（配置mapper中的type为ehcache接口的实现类型） 1&lt;cache type = "org.mybatis.caches.ehcache.EhcacheCache"/&gt; 加入ehcache的配置文件 在classpath下配置ehcache.xml 二级缓存的应用场景对于访问多的查询请求且用户对查询结果实时要求不高，此时可以采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景如下：耗时较高的统计分析sql、电话账单查询sql等 实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新时间隔fulshInterval，比如设置为30分钟、60分钟、24小时等 局限性mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下要求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都查询最新的商品信息，此时如果使用二级缓存就无法实现一个商品变化时只刷新该商品的缓存信息而不刷新其他商品的信息，因为mybatis的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有的商品信息的缓存数据全部清空。解决此类问题需要在服务层根据需求对数据进行有针对性的缓存 mybatis和spring进行整合整合思路需要spring通过单列方式管理SqlSessionFactory spring和mybatis整合生成代理对象，使用SqlSessionFactory创建SqlSession（spring和mybatis整合自动完成） 持久层的mapper都需要由spring进行管理 整合环境创建一个新的java工程（接近实际开发的工程结构） jar包： mybatis3.2.7的jar包 spring3.2.0的jar包 mybatis和spring的整合包：早期ibatis和spring整合是由spring官方提供，mybatis和spring整合由mybatis提供 SqlSessionFactory在applicationContext.xml中配置sqlSessionFactory和数据源 sqlSessionFactory在mybatis的spring的整合包下： 12345678910111213&lt;beans&gt; &lt;!--加载配置文件--&gt; &lt;context:property-placeholder location="classpath:db.properties"&gt; &lt;!--数据源，使用dbcp或者（c3p0）--&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destory-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="maxActive" value="10"/&gt; &lt;property name="maxIdle" value="5"/&gt; &lt;/bean&gt;&lt;/beans&gt; 原始dao开发mapper.xml创建mapper.xml 在SqlMapConfig.xml中加载User.xml daodao接口实现需要注入SqlSessionFactory，通过spring进行注入 这里为了更好的让大家看见，这里用spring声明配置方式，配置dao的bean 123&lt;bean id="userDao class="cn.itcast.ssm.dao.UserDaoImpl&gt; &lt;property name="" ref="SessionFactory"/&gt; &lt;/bean&gt; 让UserDaoImpl实现类继承SqlSessionDaoSupport（extends SqlSessionDaoSupport ）。继承的这个东西里面有创建会话工厂的代码 12//继承了这个东西之后，创建会话的方法SqlSession sqlSession = this.getSqlSession(); 在applicationContext.xml中配置dao mapper代理开发mapper.xmlmybatis逆向工程什么是逆向工程？mybatis需要程序员自己写sql语句，mybatis官方提供逆向工程，针对单表来生成代码，mybatis执行所需要的代码（mapper.java\mapper.xml\po） 企业的实际开发中，常用的逆向工程方式 由于数据库的表生成java代码 下载逆向工程使用方法建议使用java程序方式，不依赖开发工具]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[welcome Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
