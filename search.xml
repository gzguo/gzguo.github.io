<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java_regular_start</title>
      <link href="/2019/09/07/java/regular/start/"/>
      <url>/2019/09/07/java/regular/start/</url>
      
        <content type="html"><![CDATA[<h4 id="特殊字符、量词、零宽、匹配模式、分组、预搜索、java中的使用、网络爬虫"><a href="#特殊字符、量词、零宽、匹配模式、分组、预搜索、java中的使用、网络爬虫" class="headerlink" title="特殊字符、量词、零宽、匹配模式、分组、预搜索、java中的使用、网络爬虫"></a><center>特殊字符、量词、零宽、匹配模式、分组、预搜索、java中的使用、网络爬虫</center></h4><a id="more"></a><p><strong>regular Expression</strong></p><h1 id="正则表达式的基本知识"><a href="#正则表达式的基本知识" class="headerlink" title="正则表达式的基本知识"></a>正则表达式的基本知识</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><em>为什么需要正则表达式</em>？文本的复杂处理</p><p><em>正则表达式的优势和用途</em>：1.一种强大的文本处理工具 2.大部分编程语言、数据库、文本编译器、开发环境都支持正则表达式</p><p><em>正则表达式的定义</em>：1.正如他的名字一样描述了一个规则，通过这个规则可以匹配一类字符串 2.学习正则表达式很大程度上就是学习正则表达式的语法规则</p><p>开发中使用正则表达式：</p><ul><li>分析所要匹配的数据，写出测试用的典型数据</li><li>在工具软件中进行匹配测试</li><li>在程；序调用通过测试的正则表达式</li></ul><p>正则表达式语法：</p><p><strong>1.</strong>普通字符：字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是“普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符</p><p><strong>2.</strong>简单的转义字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\n 换行符</span><br><span class="line">\t 制表符</span><br><span class="line">\\ \本身</span><br><span class="line">\^,\$,\.,\(, \),\&#123;, \&#125;,\?,\+,\*,\|,\[, \] 匹配这些字符本身</span><br></pre></td></tr></table></figure><p><strong>3.</strong>标准字符集合：</p><p>1&gt;能够与“多种字符”匹配的表达式</p><p>2&gt;注意区分大小写，大写是相反的意思</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\d 任意一个数字，0-9中任意一个</span><br><span class="line">\w 任意一个字母或数字或下划线，也就是A-Z、a-z、0-9，_ 中任意一个</span><br><span class="line">\s 包括空格、制表符、换行符等空白符的其中任意一个</span><br><span class="line">. 小数点可以匹配任意一个字符(除了换行符)，如果要匹配“\n”在内的所有字符，一般用[\s\S]</span><br></pre></td></tr></table></figure><p><strong>4.</strong>自定义字符集合：</p><p>[]方括号匹配方式，能够匹配方括号中任意一个字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ab5@] 匹配“a”或“b”或“<span class="number">5</span>”或“@”</span><br><span class="line">[^abc] 匹配“a”，“b”，“c”之外的任意一个字符</span><br><span class="line">[f-k]  匹配“f”~“k”之间的任意一个字母</span><br><span class="line">[^A-F0-<span class="number">3</span>] 匹配“A~F”，“<span class="number">0</span>~<span class="number">3</span>”之外的任意一个字符</span><br></pre></td></tr></table></figure><p>1&gt;正则表达式的特殊符号，被包含到了中括号中，则失去了意义，除了^ - 之外</p><p>2&gt;标准字符集合，除小数点外(小数点在中括号内只表示小数点，没有特殊含义)，如果被包含于中括号，自定义字符集合将包含该集合。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[\d.\-+] 将匹配：数字、小数点、+、-</span><br></pre></td></tr></table></figure><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>量词：修饰匹配次数的特殊符号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">贪婪模式：</span><br><span class="line">&#123;n&#125; 表达式重复n次</span><br><span class="line">&#123;m,n&#125; 表达式至少重复m次，最多重复n次</span><br><span class="line">&#123;m,&#125; 表达式至少重复m次</span><br><span class="line">? 匹配表达式<span class="number">0</span>次或者<span class="number">1</span>次，相当于&#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">+ 表达式至少出现<span class="number">1</span>次，相当于&#123;<span class="number">1</span>,&#125;</span><br><span class="line">* 表达式不出现或出现任意次，相当于&#123;<span class="number">0</span>,&#125;</span><br><span class="line"></span><br><span class="line">非贪婪模式：</span><br><span class="line">&#123;n&#125;? 表达式重复n次</span><br><span class="line">&#123;m,n&#125;? 表达式至少重复m次，最多重复n次</span><br><span class="line">&#123;m,&#125;? 表达式至少重复m次</span><br></pre></td></tr></table></figure><ul><li>匹配次数中的贪婪模式(匹配字符越多越好，默认！)</li><li>匹配次数中的非贪婪模式(匹配的字符越少越好，修饰匹配次数的特殊符号后再加上一个“？”号)</li></ul><h3 id="字符边界-零宽"><a href="#字符边界-零宽" class="headerlink" title="字符边界(零宽)"></a>字符边界(零宽)</h3><p>本组标记匹配的不是字符而是位置，符合某种条件的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^ 与字符串开始的地方匹配</span><br><span class="line">$ 与字符串结束的地方匹配</span><br><span class="line">\b 匹配一个单词边界</span><br><span class="line"><span class="comment">// \b匹配这样一个位置：前面的字符和后面的字符不全是\w</span></span><br></pre></td></tr></table></figure><h3 id="正则表达式的匹配模式"><a href="#正则表达式的匹配模式" class="headerlink" title="正则表达式的匹配模式"></a>正则表达式的匹配模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IGNORECASE(ignorecase) 忽略大小写模式</span><br><span class="line"> <span class="number">1</span>&gt;匹配时忽略大小写</span><br><span class="line"> <span class="number">2</span>&gt;默认情况下，正则表达式是要区分大小写的</span><br><span class="line">SINGLELINE(singleline) 单行模式</span><br><span class="line"> <span class="number">1</span>&gt;整个文本看作一个字符串，只有一个开头，一个结尾</span><br><span class="line"> <span class="number">2</span>&gt;使小数点“.”可以匹配包含换行符(\n)在内的任意字符</span><br><span class="line">MULTILINE(multiline) 多行模式</span><br><span class="line"> <span class="number">1</span>&gt;每行都是一个字符串，都有开头和结尾</span><br><span class="line"> <span class="number">2</span>&gt;在指定MULTILINE之后，如果需要仅匹配字符串开始和结束位置，可以使用\A和\Z</span><br></pre></td></tr></table></figure><h3 id="选择符和分组"><a href="#选择符和分组" class="headerlink" title="选择符和分组"></a>选择符和分组</h3><table><thead><tr><th>表达式</th><th>作用</th></tr></thead><tbody><tr><td>| 分支结构</td><td>左右两边表达式之间“或”关系，匹配左边或者右边</td></tr><tr><td>() 捕获组</td><td>1&gt;在被修饰次数的时候，括号内的表达式可以作为整体被修饰   2&gt;取消匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到   3&gt;每一对括号会分配一个编号，使用()的捕捉根据左括号的顺序从1开始自动编号。捕获元素编号为0的第一个捕获是由整个正则表达式模式匹配的文本</td></tr><tr><td>(?:Expression) 非捕获组</td><td>一些表达式中，不得不使用()，但又不需要保存()中的子表达式匹配的内容，这时可以用非捕获来抵消()带来的副作用</td></tr></tbody></table><h4 id="反向引用-nnn"><a href="#反向引用-nnn" class="headerlink" title="反向引用(\nnn)"></a>反向引用(\nnn)</h4><ol><li>每一对()会分配一个编号，使用()的捕捉<strong>根据左括号的顺序</strong>从1开始自动编号</li><li>通过反向引用，可以对分组已捕获的字符串进行引用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">([a-z]&#123;<span class="number">2</span>&#125;)\<span class="number">1</span> 匹配gogo 、 toto 这类型的前两个字母是小写并且后两个字母和前两个字母相同</span><br><span class="line">(?:[a-z]&#123;<span class="number">2</span>&#125;) 只利用括号的形式，没有存储捕获的内容。后面写\<span class="number">1</span>也失去了意义</span><br></pre></td></tr></table></figure><h2 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h2><h3 id="预搜索-零宽断言"><a href="#预搜索-零宽断言" class="headerlink" title="预搜索(零宽断言)"></a>预搜索(零宽断言)</h3><p>预搜索(零宽断言)：也叫<strong>环视</strong></p><ul><li>只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度</li><li>这个位置应该符合某个条件。判断当前位置的前后字符，是否符合指定条件，但不匹配前后字符。是对位置的匹配</li><li>正则表达式匹配的过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是零宽度的。占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(?=exp) 断言自身出现的位置的后面能匹配表达式exp</span><br><span class="line">(?&lt;=exp) 断言自身出现的位置的前面能匹配表达式exp</span><br><span class="line">(?!exp) 断言此位置的后面不能匹配表达式exp</span><br><span class="line">(?&lt;!exp) 断言此位置的前面不能匹配表达式exp</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[a-z]+(?=ing) 匹配以ing结尾的小写单词 例如：going、eating、doing，但是ing本身不会被匹配</span><br><span class="line">[a-z]+(?=\d+) 匹配以数字结尾的单词，数字本身不计入匹配结果</span><br><span class="line">+ ：至少出现一次</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="电话号码"><a href="#电话号码" class="headerlink" title="电话号码"></a>电话号码</h3><p>电话号码验证：</p><ul><li>电话号码由数字和“-”构成</li><li>电话号码为7到8位</li><li>如果电话号码中包含有区号，那么区号为三位或四位，首位是0</li><li>区号用“-”和其他部分隔开</li><li>移动电话号码为11位</li><li>11位移动电话号码的第一位和第二位为“13”，“15”，“18”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>\d&#123;<span class="number">2</span>,<span class="number">3</span>&#125;-\d&#123;<span class="number">7</span>,<span class="number">9</span>&#125;)|(<span class="number">1</span>[<span class="number">35789</span>]\d&#123;<span class="number">9</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="电子邮箱"><a href="#电子邮箱" class="headerlink" title="电子邮箱"></a>电子邮箱</h3><p>电子邮箱地址验证：</p><ul><li>用户名：字母、数字、中划线、下划线组成</li><li>@</li><li>网址：字母、数字组成</li><li>组织域名：2-4位字母组成</li><li>不区分大小写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[\w\-]+@[a-z0-<span class="number">9</span>A-Z]+(\.[A-Za-z]&#123;<span class="number">2</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">\- 代表中划线</span><br></pre></td></tr></table></figure><h2 id="使用正则"><a href="#使用正则" class="headerlink" title="使用正则"></a>使用正则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">匹配中文字符：[\u4e00-\u9fa5]</span><br><span class="line">匹配空白行：\n\s*\r</span><br><span class="line">匹配HTML标记：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;^<span class="number">1</span>&gt;|&lt;.*?/&gt;</span><br><span class="line">匹配首尾空白字符串：^\s*|\s*$</span><br><span class="line">匹配Email地址：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*</span><br><span class="line">匹配网址URL：[a-zA-Z]+:<span class="comment">//[^\s]*</span></span><br><span class="line">匹配国内电话号码：\d&#123;<span class="number">3</span>&#125;-\d&#123;<span class="number">8</span>&#125;|\d&#123;<span class="number">4</span>&#125;-\d&#123;<span class="number">7</span>&#125;</span><br><span class="line">匹配腾讯QQ号：[<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">4</span>,&#125;</span><br><span class="line">匹配中国邮政编码：[<span class="number">1</span>-<span class="number">9</span>]\d&#123;<span class="number">5</span>&#125;(?!\d)</span><br><span class="line">匹配身份证：\d&#123;<span class="number">15</span>&#125;|\d&#123;<span class="number">18</span>&#125;</span><br><span class="line">匹配ip地址：\d+\.\d+\.\d+\.\d+</span><br></pre></td></tr></table></figure><h3 id="java中使用正则"><a href="#java中使用正则" class="headerlink" title="java中使用正则"></a>java中使用正则</h3><ul><li>相关的类位于：java.util.regex包下面</li><li>类Pattern：1.正则表达式的编译表示形式 2.Pattern p = Pattern.compile(r,int); //建立正则表达式，并启用相应模式</li><li>类Matcher：1.通过解释Pattern对character sequence执行匹配操作的引擎 2.MAtcher m = p.matcher(str); //匹配str字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//在这个字符串：asfsdf23323，是否符合指定的正则表达式：\w+</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//表达式对象</span></span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">"\\w+"</span>); <span class="comment">//正则表达式中的\在java中变\\</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建Matcher对象(匹配对象)</span></span><br><span class="line">        Matcher m = p.matcher(<span class="string">"asfsdf23323"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匹配一下，返回结果是boolean</span></span><br><span class="line">        <span class="comment">//尝试将整个字符序列与该模式匹配</span></span><br><span class="line">        <span class="keyword">boolean</span> yesorno = m.matches();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//该方法扫描输入的序列，查找与该模式匹配的下一个子序列</span></span><br><span class="line">        <span class="comment">//boolean a = m.find();</span></span><br><span class="line">        <span class="comment">//System.out.println(a); true //m.group() 把匹配到的内容返回</span></span><br><span class="line">        <span class="comment">//System.out.println(a); true</span></span><br><span class="line">        <span class="comment">//System.out.println(a); false</span></span><br><span class="line">        <span class="comment">//System.out.println(a); false</span></span><br><span class="line">        <span class="comment">//group()和group(0)匹配整个表达式的子字符串</span></span><br><span class="line">        System.out.println(yesorno); <span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find和group操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGroup</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">"([a-z]+)([0-9]+)"</span>);</span><br><span class="line">        Matcher m = p.matcher(<span class="string">"aa232**ssd445*sds223"</span>);</span><br><span class="line">        <span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">            System.out.println(m.group()); <span class="comment">//group(0)和group()一样</span></span><br><span class="line">            System.out.println(m.group(<span class="number">1</span>)); <span class="comment">//第一个()中查到的内容</span></span><br><span class="line">            System.out.println(m.group(<span class="number">2</span>));</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 输出结果：</span></span><br><span class="line"><span class="comment">             * aa232</span></span><br><span class="line"><span class="comment">             * aa</span></span><br><span class="line"><span class="comment">             * 232</span></span><br><span class="line"><span class="comment">             * ssd445</span></span><br><span class="line"><span class="comment">             * ss</span></span><br><span class="line"><span class="comment">             * 445</span></span><br><span class="line"><span class="comment">             * sds223</span></span><br><span class="line"><span class="comment">             * sds</span></span><br><span class="line"><span class="comment">             * 223</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReplace</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">"[0-9]"</span>);</span><br><span class="line">        Matcher m = p.matcher(<span class="string">"aa223**ss445*sds223"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//替换</span></span><br><span class="line">        String newStr = m.replaceAll(<span class="string">"#"</span>);</span><br><span class="line">        System.out.println(newStr);</span><br><span class="line">        <span class="comment">//输出结果：aa###**ss###*sds###</span></span><br><span class="line">        <span class="comment">//并不会改变原有的字符串，newStr是新生成的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分割</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSplit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str = <span class="string">"aa223**ss445*sds223"</span>;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">"[0-9]"</span>);</span><br><span class="line">        Matcher m = p.matcher(str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//分割</span></span><br><span class="line">        String[] arrs = str.split(<span class="string">"\\d+"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arrs));</span><br><span class="line">        <span class="comment">//输出结果：[aa, **ss, *sds]</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="java复杂文本操作"><a href="#java复杂文本操作" class="headerlink" title="java复杂文本操作"></a>java复杂文本操作</h1><h2 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//网络爬虫取链接</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSpiderCore</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得url对应的网页的源码内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getURLContent</span><span class="params">(String URL)</span></span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Url url = <span class="keyword">new</span> Url(URL);</span><br><span class="line">            BufferedReader reader = </span><br><span class="line">                <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader</span><br><span class="line">                                   (url.openStream(),Charset.forName(<span class="string">"gbk"</span>)));</span><br><span class="line">            String temp = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span>(temp = reader.readLine() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                sb.append(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String destStr = getURLContent(<span class="string">"http://www.163.com"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记得\变\\</span></span><br><span class="line">        <span class="comment">//取到超链接中的所有内容</span></span><br><span class="line">        <span class="comment">//Partten p = Partten.compile("&lt;a[\\s\\S]+?&lt;/a&gt;");</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//取到超链接的地址</span></span><br><span class="line">        <span class="comment">//Partten p = Partten.compile("href=\".+?\"");</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只取超链接</span></span><br><span class="line">        <span class="comment">//分组、预搜索(零宽断言)</span></span><br><span class="line">        Partten p = Partten.compile(<span class="string">"href=\"(.+?)\""</span>);</span><br><span class="line">        <span class="comment">//String str = "href=\"([\\w\\s./:]+?)\"";</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * ?简介：</span></span><br><span class="line"><span class="comment">         * 当该字符紧跟在任何一个其他限制符 (*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;) 后面时，</span></span><br><span class="line"><span class="comment">         * 匹配模式是非贪婪的。</span></span><br><span class="line"><span class="comment">         * 非贪婪模式尽可能少的匹配所搜索的字符串，</span></span><br><span class="line"><span class="comment">         * 而默认的贪婪模式则尽可能多的匹配所搜索的字符串。</span></span><br><span class="line"><span class="comment">         * 例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Matcher m = p.matcher(deseStr);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">            <span class="comment">//取到超链接的地址</span></span><br><span class="line">            System.out.println(m.group());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//只取超链接</span></span><br><span class="line">            System.out.println(m.group(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> regular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_network_start</title>
      <link href="/2019/09/05/java/network/start/"/>
      <url>/2019/09/05/java/network/start/</url>
      
        <content type="html"><![CDATA[<h4 id="java-network-start"><a href="#java-network-start" class="headerlink" title="java_network_start"></a><center>java_network_start</center></h4><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>database</title>
      <link href="/2019/09/02/database/start/"/>
      <url>/2019/09/02/database/start/</url>
      
        <content type="html"><![CDATA[<h4 id="database"><a href="#database" class="headerlink" title="database"></a><center>database</center></h4><a id="more"></a><p>根据数据库模型的发展，可以划分为三个阶段：</p><p>第一代：网状、层次数据库系统</p><p>第二代：关系型数据库</p><p>第三代：面向对象模型为主要特征的数据库系统</p><p>数据库：</p><p>IBM ：IMS(层次数据库，早期)   SQL/Ds(关系型数据库，后来)   DB2(关系型数据库，再后来)   </p><p>Oracle ：Oracle数据库(世界上流行的关系型数据库)</p><p>微软 ：SQL Server(关系型数据库)</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_io_start</title>
      <link href="/2019/09/02/java/io/start/"/>
      <url>/2019/09/02/java/io/start/</url>
      
        <content type="html"><![CDATA[<h4 id="java-io-start"><a href="#java-io-start" class="headerlink" title="java_io_start"></a><center>java_io_start</center></h4><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_thread_next</title>
      <link href="/2019/09/02/java/thread/next/"/>
      <url>/2019/09/02/java/thread/next/</url>
      
        <content type="html"><![CDATA[<h4 id="线程的方法、优先级、并发、死锁"><a href="#线程的方法、优先级、并发、死锁" class="headerlink" title="线程的方法、优先级、并发、死锁"></a><center>线程的方法、优先级、并发、死锁</center></h4><a id="more"></a><h1 id="线程的方法"><a href="#线程的方法" class="headerlink" title="线程的方法"></a>线程的方法</h1><p>线程的基本信息</p><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>isAlive()</td><td>判断线程是否还”活着”，即线程是否还未终止</td></tr><tr><td>getPriority()</td><td>获得线程的优先级数值</td></tr><tr><td>setPriority()</td><td>设置线程的优先级数值</td></tr><tr><td>setName()</td><td>给线程一个名字</td></tr><tr><td>getName()</td><td>取得线程的名字</td></tr><tr><td>currentThread()</td><td>取得当前正在运行的线程对象也就是取得自己本身</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            <span class="comment">//Thread.currentThread().getName(),这是静态方法，放在那就代表哪个线程</span></span><br><span class="line">            <span class="comment">//Thread.currentThread().getName(),代表当前的MyThread线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"："</span>+num++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//也可以用构造方法给线程起名字</span></span><br><span class="line">        Thread proxy = <span class="keyword">new</span> Thread(t1);</span><br><span class="line">        proxy.setName(<span class="string">"test"</span>);</span><br><span class="line">        System.out.println(proxy.getName()); <span class="comment">//得到MyThread线程的名字</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()); <span class="comment">//main线程</span></span><br><span class="line">        proxy.start();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        t1.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><p>线程的优先级：MAX_PRIORITY(max_priority)默认是10、NORM_PRIORITY默认是5、MIN_PRIORITY默认是1</p><p>优先级代表的是概率，不是绝对的先后顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            <span class="comment">//Thread.currentThread().getName(),这是静态方法，放在那就代表哪个线程</span></span><br><span class="line">            <span class="comment">//Thread.currentThread().getName(),代表当前的MyThread线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"："</span>+num++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread p1 = <span class="keyword">new</span> Thread(t1,<span class="string">"t1"</span>);</span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread p2 = <span class="keyword">new</span> Thread(t2,<span class="string">"t2"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置优先级</span></span><br><span class="line">        <span class="comment">//优先级代表的是概率，不是绝对的先后顺序</span></span><br><span class="line">        p1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        p2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        p1.start();</span><br><span class="line">        p2.start();</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        t1.stop();</span><br><span class="line">        t2.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程并发-同步"><a href="#线程并发-同步" class="headerlink" title="线程并发/同步"></a>线程并发/同步</h1><p>同步也称为并发(<strong>多个线程访问同一份资源，造成资源不安全</strong>，我们就要确保资源安全)</p><p>线程安全：确保资源安全</p><h2 id="synchronize"><a href="#synchronize" class="headerlink" title="synchronize"></a>synchronize</h2><p>synchronized同步(线程安全) 1.同步块  2.同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(引用类型|<span class="keyword">this</span>|类.class)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建真实角色</span></span><br><span class="line">        Web12306 web = <span class="keyword">new</span> Web12306();</span><br><span class="line">        <span class="comment">//代理</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(web,<span class="string">"甲"</span>); </span><br><span class="line">        <span class="comment">//"甲" 是Thread.currentThread().getName()，是这个线程的名字</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(web,<span class="string">"乙"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(web,<span class="string">"丙"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Web12306</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//test和test1的效果是一样的</span></span><br><span class="line">    <span class="comment">//线程安全，锁定正确</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="keyword">false</span>; <span class="comment">//跳出循环，结束线程</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>); <span class="comment">//模拟延时</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"抢到了"</span>+num--);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//锁对象的this</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="keyword">false</span>; <span class="comment">//跳出循环，结束线程</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>); <span class="comment">//模拟延时</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"抢到了"</span>+num--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>单例设计模式：确保一个类只有一个对象</p><p>懒汉式：</p><ol><li>构造器私有化，避免外部直接创建对象</li><li>声明一个私有的静态变量</li><li>创建一个对外的公共静态方法访问该变量，如果变量没有对象，创建该对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jvm</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Jvm instance =  <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器私有化，避免外部直接创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Jvm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个对外的公共静态方法访问该变量，如果变量没有对象，创建该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Jvm <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Jvm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jvm</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Jvm instance =  <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器私有化，避免外部直接创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Jvm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个对外的公共静态方法访问该变量，如果变量没有对象，创建该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jvm <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//this是成员的，是对象的，静态的没有。只能锁类</span></span><br><span class="line">        <span class="comment">//和上面的效果是一样的</span></span><br><span class="line">        <span class="keyword">synchronized</span>(Jvm.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Jvm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jvm <span class="title">getInstance2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//提供了已经存在的对象的访问效率</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            <span class="comment">//this是成员的，是对象的，静态的没有。只能锁类</span></span><br><span class="line">        <span class="comment">//和上面的效果是一样的</span></span><br><span class="line">        <span class="keyword">synchronized</span>(Jvm.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Jvm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恶汉式：</p><ol><li>构造器私有化，避免外部直接创建对象</li><li>声明一个私有的静态变量，同时创建该对象</li><li>对外提供访问属性的静态方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jvm</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Jvm instance =  <span class="keyword">new</span> Jvm();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器私有化，避免外部直接创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Jvm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jvm <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jvm</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部类，延缓加载时机</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Jvm instance =  <span class="keyword">new</span> Jvm();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器私有化，避免外部直接创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Jvm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jvm <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JvmHodler.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>过多的同步容易造成死锁</p><p>死锁就是多份资源，但是资源的使用者有相同的，创建进程的时候就会出现死锁的现象</p><p>解决这个问题的思路：生产者、消费者模式</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>front_start</title>
      <link href="/2019/09/01/front/start/"/>
      <url>/2019/09/01/front/start/</url>
      
        <content type="html"><![CDATA[<h4 id="front-start"><a href="#front-start" class="headerlink" title="front_start"></a><center>front_start</center></h4><a id="more"></a><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>常见的浏览器：Opra、FireFox、InternetExplorer、Safari、Chrome(用户最多)、QQ浏览器</p><p>安卓的浏览器：(安卓是Google团队开发的) 安卓的浏览器本质上是Chrome</p><p>苹果的浏览器：Safari</p><p>微信的网页是由QQ浏览器支持的</p><h3 id="W3C"><a href="#W3C" class="headerlink" title="W3C"></a>W3C</h3><p>W3C：软件行业最庞大、最权威的组织，它制定了很多的行业标准</p><p>W3C：World Wide Web Consortium 万维网联盟 ，不是公司，<strong>是非营利的组织</strong>，没有总部。</p><p>W3C在世界上建立了四个中心：麻省理工学院、欧洲数学与信息学研究联盟、东京庆应大学、北京航空航天大学</p><p>类似的组织：<strong>OpenSSL</strong>(全世界80%以上的网络通信都使用了OpenSSL提供的加密工具来保证信息的安全)</p><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>H5：HTML5 &lt; web前端</p><p>这些&lt;标记文字&gt;不再是普通的文字内容，他们不会显示在页面上，每个标记都有自己的作用，这些标记超越了普通文本的意义，叫做HyperText(超文本)他们全部以标记的形式来书写。所以我们才叫HTML(超文本标记语言 HyperText Markup Language)</p><h3 id="他们之间的关系"><a href="#他们之间的关系" class="headerlink" title="他们之间的关系"></a>他们之间的关系</h3><p>浏览器是网页的载体，网页需要在浏览器里运行</p><p>编写网页的语言叫HTML，规则由W3C制定</p><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>编译工具(器)：HbuilderX(VSCode、Sublime Text、WebStorm、Atom)</p><p>我们现在的HTML是HTML5(2014年) 相对于HTML(1997) 是一个重大的突破</p><p>我们要注意代码缩进，使用电脑上的tab键进行代码缩进</p><h2 id="网页的基本结构"><a href="#网页的基本结构" class="headerlink" title="网页的基本结构"></a>网页的基本结构</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span> <span class="comment">&lt;!--这句声明，就是告诉浏览器，请使用HTML5的标准来解析这个网页--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="comment">&lt;!--head表示网页的头部，这里的信息都是对网页的整体说明--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span> = <span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>这是网页的标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="comment">&lt;!--body表示网页的身体，网页的主要内容都写在这里--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            P标签代表段落，因此这里的内容会单独占一行</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里的内容不会显示在页面上，它通常用来注释我们的程序代码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HbuilderX内置的服务器可以帮我们自动刷新页面，不需要手动点击刷新</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    标题标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span></span><br><span class="line">    标题标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">P标签代表段落，因此这里的内容会单独占一行，文字独占一行</span><br><span class="line">    段落标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>加粗<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span> <span class="comment">&lt;!--加分割线/水平线--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="comment">&lt;!--换行--&gt;</span></span><br><span class="line">&amp;nbsp <span class="comment">&lt;!--代表一个空格--&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> front </category>
          
      </categories>
      
      
        <tags>
            
            <tag> front </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>database_compared_start</title>
      <link href="/2019/09/01/database/compared/start/"/>
      <url>/2019/09/01/database/compared/start/</url>
      
        <content type="html"><![CDATA[<h4 id="database-compared-start"><a href="#database-compared-start" class="headerlink" title="database_compared_start"></a><center>database_compared_start</center></h4><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compared </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_container_start</title>
      <link href="/2019/08/31/java/container/start/"/>
      <url>/2019/08/31/java/container/start/</url>
      
        <content type="html"><![CDATA[<h4 id="java-container-start"><a href="#java-container-start" class="headerlink" title="java_container_start"></a><center>java_container_start</center></h4><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> container </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_exception_start</title>
      <link href="/2019/08/30/java/exception/start/"/>
      <url>/2019/08/30/java/exception/start/</url>
      
        <content type="html"><![CDATA[<h4 id="异常分类、处理、方法重写时的声明原则、自定义异常"><a href="#异常分类、处理、方法重写时的声明原则、自定义异常" class="headerlink" title="异常分类、处理、方法重写时的声明原则、自定义异常"></a><center>异常分类、处理、方法重写时的声明原则、自定义异常</center></h4><a id="more"></a><p>让大家写一个程序：将d:/a.txt复制到e:/a.txt</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">"d:/a.txt"</span>这个文件存在)&#123;</span><br><span class="line">    <span class="keyword">if</span>(e盘的空间大于a.exe文件长度)&#123;</span><br><span class="line">        <span class="keyword">if</span>(文件复制一半io流断掉)&#123;</span><br><span class="line">            停止copy，输出：io流出现问题！</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            copyFile(<span class="string">"d:/a.txt"</span>,<span class="string">"e:/a.txt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        输出：e盘的空间不足</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    输出：a.exe不存在</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的话有两个坏处：</p><ul><li>逻辑代码和错误处理代码放在一起</li><li>程序员本身需要考虑的例外情况比较复杂。对程序员本身要求比较高</li></ul><p>软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是Exception，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序作出合理的处理？而不至于程序崩溃</p><p>常见的异常：</p><ul><li>用户输入错误</li><li>设备错误</li><li>硬件问题，比如打印机关掉、服务器问题</li><li>物理限制：硬盘满了</li></ul><h1 id="异常的概念"><a href="#异常的概念" class="headerlink" title="异常的概念"></a>异常的概念</h1><p>java异常是java提供的用于处理程序错误的一种机制</p><p>java是采用面向对象的方式来处理异常的。处理过程：</p><p>抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE</p><p>捕获异常：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法调用栈种查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止</p><p>类 java.lang.Throwable 的子类：Error、Exception</p><p>Error错误，不需要程序员处理，直接重启</p><p>Exception例外：需要程序员处理</p><h1 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h1><p>JDK中定义了很多异常类，这些类对应了各种各样的可能出现的异常事件，所有的异常对象都是派生于Throwable类的一个实例。如果内置的异常类不能够满足需要，还可以自己创建自己的异常类</p><p>Exception分为：CheckedException和(RuntimeException)UncheckedExcetion</p><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><ul><li>Error类层次描述了java运行时系统内部和资源耗尽的错误。这类错误是我们无法控制的，同时也是非常罕见的错误。所以在编程中，不去处理这类错误。</li><li>Error表明系统JVM已经处于不可恢复的崩溃状态中。</li><li>打开JDK包：java.lang.error，查看他的所有子类</li><li>注：我们不需要管理Error</li></ul><h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><ul><li><p>所有异常的父类，其子类对应了各种各样可能出现的异常事件</p></li><li><p>Runtime Exception(Unchacked Exception)比较频繁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.一些特殊的异常，比如被<span class="number">0</span>除、数组下标超范围等，其产生比较频繁，处理麻烦，如果显式的声明或捕捉将会对程序可读性和运行效率影响很大。因此由系统自动检测并将他们交给缺省的异常处理程序</span><br><span class="line"><span class="number">2</span>.常见的Runtime Exception：</span><br><span class="line">AirthmeticException/NullPointerException/ClassCastException/ArrayIndexOutOfBoundsException/NumberFormatException</span><br></pre></td></tr></table></figure></li></ul><ul><li>Checked Exception：这一类异常，我们需要捕获进行处理</li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="trycatch"><a href="#trycatch" class="headerlink" title="trycatch"></a>trycatch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有异常，就不会执行catch</span></span><br><span class="line"><span class="comment">//遇到异常的话，会在catch块中做处理</span></span><br><span class="line"><span class="comment">//不管有没有异常，finally都会执行</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//语句1</span></span><br><span class="line">    <span class="comment">//语句2</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">//语句3</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//语句4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="try"><a href="#try" class="headerlink" title="try"></a>try</h3><p>try语句制定了一段代码，该代码就是一次捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该段中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，他后面的catch语句要分别对这些异常做相应的处理</p><p>注：当异常处理的代码执行结束之后，是不会回到try语句去执行尚未执行的代码</p><h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><ul><li><p>每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象</p></li><li><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">toString()方法，显示异常的类名和产生异常的原因</span><br><span class="line">getMessage()方法，只显示产生异常的原因，但不显示类名</span><br><span class="line">printStackTrace()方法，用来跟踪异常事件发生时堆栈的内容</span><br><span class="line"><span class="comment">//这些方法均继承自Throwable类</span></span><br></pre></td></tr></table></figure></li><li><p>Catch捕获异常时的顺序：如果异常之间有继承关系，在顺序安排上需注意。越是顶层的类，越放在下面</p></li></ul><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>有些语句，不管是否发生了异常，都必须执行，那么就可以把这样的语句放到finally语句块中</p><p>通常在finally中关闭程序快已打开的资源，比如，文件流、释放数据库连接等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FileReader reader = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            reader = <span class="keyword">new</span> FileReader(<span class="string">"d:/a.txt"</span>);</span><br><span class="line">            <span class="keyword">char</span> temp = (<span class="keyword">char</span>)reader.read();</span><br><span class="line">            System.out.println(<span class="string">"读出的内容："</span>+temp);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"文件没有找到"</span>);</span><br><span class="line">            e.printlnStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"读取文件错误"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"不管有没有异常，我肯定会被执行"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="try-catch、finally、return的执行顺序"><a href="#try-catch、finally、return的执行顺序" class="headerlink" title="try catch、finally、return的执行顺序"></a>try catch、finally、return的执行顺序</h4><ul><li>执行try、catch，给返回值赋值，没有立即返回</li><li>执行finally</li><li>return //finally里面一般不要加retun，会把之前返回值赋的值覆盖掉</li></ul><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><p>声明异常：throws子句</p><ul><li>当Checked Exception产生时，不一定立刻处理它，可以再把异常Throws出去</li><li>如果一个方法抛出多个已检查异常，就必须在方法的首部列出所有的异常，之间以逗号隔</li></ul><h3 id="方法重写中声明异常的原则"><a href="#方法重写中声明异常的原则" class="headerlink" title="方法重写中声明异常的原则"></a>方法重写中声明异常的原则</h3><ol><li>父类没有声明异常，子类也不能</li><li>不可抛出原有方法抛出异常类的父类或上层类</li><li>抛出的异常类型的数目不可以比原有的方法抛出的还多(不是指某个类型的个数)</li></ol><h2 id="手动抛出throw"><a href="#手动抛出throw" class="headerlink" title="手动抛出throw"></a>手动抛出throw</h2><ul><li><p>java异常类对象除在程序执行过程中出现异常时系统自动生成并抛出，也可以根据需要的手工创建并抛出</p></li><li><p>在捕获一个异常前，必须要有一段代码先生成异常对象并将他们抛出。这个过程我们可以手工做，也可以由JRE来实现，但是他们调用的都是throw子句</p></li><li><p>对于一个已经存在的异常类，抛出该异常对象过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.找到一个合适的异常类</span><br><span class="line">2.创建一个该类的对象</span><br><span class="line">3.将对象抛出java</span><br></pre></td></tr></table></figure></li></ul><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>自定义异常：</p><ul><li><p>在程序中，可能会遇到任何标准异常类都没有充分描述清楚的问题，这种情况下可以创建自己的异常类</p></li><li><p>从Exception类或者他的子类派生一个子类即可</p></li><li><p>习惯上，定义的类应该包含2个构造器：一个是默认的构造器，另一个是带有详细信息的构造器</p></li><li><p>事列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyException</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> MyException</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">new</span> TestMyException().test();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用异常机制建议"><a href="#使用异常机制建议" class="headerlink" title="使用异常机制建议"></a>使用异常机制建议</h2><p>使用异常机制的建议：</p><ul><li>要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率下降</li><li>处理异常不可以代替简单测试，只在异常情况下使用异常机制</li><li>不要进行小力度的异常，应该将整个任务包装在一个Try语句块中</li><li>异常往往在高层处理</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> exception </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_thread_start</title>
      <link href="/2019/08/29/java/thread/start/"/>
      <url>/2019/08/29/java/thread/start/</url>
      
        <content type="html"><![CDATA[<h4 id="基本概念、开启线程、线程状态、线程阻塞"><a href="#基本概念、开启线程、线程状态、线程阻塞" class="headerlink" title="基本概念、开启线程、线程状态、线程阻塞"></a><center>基本概念、开启线程、线程状态、线程阻塞</center></h4><a id="more"></a><h1 id="进程线程基本概念"><a href="#进程线程基本概念" class="headerlink" title="进程线程基本概念"></a>进程线程基本概念</h1><p>程序、进程和线程的基本概念：</p><ul><li><p>程序：Program指令集，静态概念，就相当于一个项目的代码，写完就放在那不动了</p></li><li><p>进程：Process操作系统调度程序，动态概念，一个程序就是一个进程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.进程是程序的一次动态执行过程，占用特定的地址空间</span><br><span class="line"><span class="number">2</span>.每个进程都是独立的，由三部分组成cpu、data、code</span><br><span class="line"><span class="number">3</span>.缺点：内存的浪费，cpu的负担</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>线程：thread在进程内多条执行路径，随着程序的复杂，由于一条路径无法满足条件，就出现了多条路径，也就是我们看到的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.线程又被称为轻量级进程</span><br><span class="line"><span class="number">2</span>.一个进程可拥有多个并行的线程</span><br><span class="line"><span class="number">3</span>.一个进程中的线程共享相同的内存单元/内存地址空间，可以访问相同的变量和对象，而且他们从同一堆中分配对象，通信、数据交换、同步操作</span><br><span class="line"><span class="comment">//第三句话的意思就是说，线程可以共享数据，共享一份数据，就容易造成并发</span></span><br><span class="line"><span class="number">4</span>.由于线程间的通信是在同一地址空间上进行的，所以不需要额外的通信机制，这就使得通信更简便而且信息传递的速度也更快</span><br><span class="line"><span class="comment">//还是在同一条道路上，在进程上，所以信息交互很方便</span></span><br></pre></td></tr></table></figure></li></ul><p>异常、main方法、gc这三者，在底层的实现，就是依靠多线程</p><h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><table><thead><tr><th>区别</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>根本区别</td><td>作为资源分配单位</td><td>调度和执行的单位</td></tr><tr><td>开销</td><td>每个进程都有独立的代码和数据空间(进程上下文)，进程间的切换会有较大的开销</td><td>线程可以看成轻量级的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换的开销小</td></tr><tr><td>所处环境</td><td>在操作系统中能同时进行多个任务(程序)</td><td>在同一应用程序中有多个顺序流同时执行</td></tr><tr><td>分配内存</td><td>系统在运行的时候会为每个进程分配不同的内存区域</td><td>除了CPU之外，不会为线程分配内存(线程所使用的资源是它所属的进程资源)，线程组只能共享资源</td></tr><tr><td>包含关系</td><td>没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个线程，则执行过程不是一条线的，而是多条线(线程)共同完成的</td><td>线程是进程的一部分，所有线程有的时候被称之为是轻权进程或者轻量级的进程</td></tr></tbody></table><h1 id="java中实现多线程"><a href="#java中实现多线程" class="headerlink" title="java中实现多线程"></a>java中实现多线程</h1><h2 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h2><p><strong>1.继承Thread + 重写run()；2.启动：创建子类对象 + 对象.start()</strong></p><p>java实现多线程：</p><ul><li>在java中负责线程的这个功能是java.lang.Thread这个类</li><li>可以通过创建Thread的实例来创建新的线程</li><li>每个线程都是通过某个特定Thread对象所对应的run()来完成其操作的，方法run()称为线程体。run就相当于程序中的main方法，是个入口。run方法里面的内容就是线程体</li><li>通过调用Thread类的start()方法来启动一个线程</li></ul><p>继承Thread的缺点：(解决方案：实现Runnable)</p><ul><li><p>继承Thread类方式的缺点：那就是如果我们的类已经从一个类继承(如小程序必须继承自Applet类)，则无法再继承Thread类</p></li><li><p>通过Runnable接口实现多线程</p></li><li><p>优点：可以同时实现继承。实现Runnable接口方式要通用一些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过实现Runnable，来实现多线程的优点：</span><br><span class="line"><span class="number">1</span>.避免单继承</span><br><span class="line"><span class="number">2</span>.方便共享资源，同一份资源，多个代理访问</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line">### 模拟龟兔赛跑</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">1. 创建多线程，继承Thread + 重写run(线程体)</span><br><span class="line">2. 使用线程：创建子类对象 + 对象.start()方法</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">public class Rabbit extends Thread&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        //线程体</span><br><span class="line">        for(int i = 0; i &lt; 100; i++)&#123;</span><br><span class="line">            System.out.println(&quot;兔子跑了&quot;+i+&quot;步&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RabbitApp&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        //创建子类对象，只不过是线程类的对象而已</span><br><span class="line">        Rabbit rab = new Rabbit();</span><br><span class="line">        //调用start方法，start会把对象加到线程中，start相当于开辟一条路</span><br><span class="line">        rab.start(); //不要调用run方法，run方法在start内部被调用</span><br><span class="line">        //如果调用run，就不会加到线程中，没有开辟路径，不是多线程，还是单线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承Thread的缺点"><a href="#继承Thread的缺点" class="headerlink" title="继承Thread的缺点"></a>继承Thread的缺点</h3><ul><li><p>继承Thread类方式的缺点：那就是如果我们的类已经从一个类继承(如小程序必须继承自Applet类)，则无法再继承Thread类</p></li><li><p>通过Runnable接口实现多线程</p></li><li><p>优点：可以同时实现继承。实现Runnable接口方式要通用一些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过实现Runnable，来实现多线程的优点：</span><br><span class="line"><span class="number">1</span>.避免单继承</span><br><span class="line"><span class="number">2</span>.方便共享资源，同一份资源，多个代理访问</span><br></pre></td></tr></table></figure></li></ul><p>Runnable接口使用了一种代理模式：称为<strong>静态代理</strong></p><h2 id="静态代理-Runnable"><a href="#静态代理-Runnable" class="headerlink" title="静态代理(Runnable)"></a>静态代理(Runnable)</h2><p>静态代理(Runnable接口实现多线程)：<strong>1.实现Runnable + 实现run()；2.启动：使用静态代理</strong></p><p>具体的实现步骤：<strong>1.创建真实角色</strong> <strong>2.创建代理角色 Thread + 引用</strong> <strong>3.代理角色.start()</strong></p><p>推荐使用接口：<strong>1.避免单继承的局限性 2.便于共享资源</strong></p><p>静态代理模式的条件：</p><ul><li>真实角色</li><li>代理角色：持有真实角色的引用</li><li>二者要实现相同的接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟个人和婚庆公司，初步体会面向接口开发</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="comment">/*public abstract*/</span> <span class="function"><span class="keyword">void</span> <span class="title">marry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实角色，实现Marry</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"you and me"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理角色，实现Mary</span></span><br><span class="line"><span class="keyword">public</span> WeddingCompany implements Marry&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Marry you;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(Marry you)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.you = you;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"布置房间"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收拾房间"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Marry</span><span class="params">()</span></span>&#123;</span><br><span class="line">        you.marry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建真实角色</span></span><br><span class="line">        <span class="comment">/*Marry*/</span>You you = <span class="keyword">new</span> You();</span><br><span class="line">        <span class="comment">//创建代理角色+真实角色的引用</span></span><br><span class="line">        <span class="comment">/*Marry*/</span>WeddingCompany company = <span class="keyword">new</span> WeddingCompany(you);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        company.marry();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 执行结果：</span></span><br><span class="line"><span class="comment">         * 布置房间</span></span><br><span class="line"><span class="comment">         * you and me</span></span><br><span class="line"><span class="comment">         * 收拾房间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//真正结婚的是你</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程静态代理的实现：(我们需要做的只有：<strong>1.创建真实角色重写run；2.交给Thread</strong>)</p><p>Runnable接口：Thread已经实现了，相当于代理角色</p><p><strong>我们只需要创建一个真实角色</strong>，后续的操作交给Thread处理就行</p><p>真实角色中只要<strong>重写run方法</strong>即可</p><p>还有最后一个问题：</p><p>代理角色怎么<strong>持有真实角色的引用</strong>？Thread(Runnable target);构造方法/构造器</p><p>都弄好之后，这就是一个静态代理</p><p><em>后面会学习反射的时候会学到动态代理：静态代理和动态代理的实现的功能是一样的，静态代理的代理角色是写死的。但是动态代理的话，这个类是运行过程中动态创建的，是一个动态的行为</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟表演，都要实现Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Runnable创建线程</span></span><br><span class="line"><span class="comment"> * 1.类实现Runnable接口 + 重写run() //这个类是我们的真实角色</span></span><br><span class="line"><span class="comment"> * 2.启动多线程，使用静态代理</span></span><br><span class="line"><span class="comment"> *   1&gt;创建真实角色</span></span><br><span class="line"><span class="comment"> *   2&gt;创建代理角色 + 对真实角色的引用</span></span><br><span class="line"><span class="comment"> *   3&gt;调用.start() 启动线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实角色</span></span><br><span class="line"><span class="comment"> * 类实现Runnable接口 + 重写run()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//线程体</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"创建角色的表演"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgrammerApp</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1&gt;创建真实角色</span></span><br><span class="line">        Programmer pro = <span class="keyword">new</span> Programmer();</span><br><span class="line">        <span class="comment">//2&gt;创建代理角色 + 对真实角色的引用</span></span><br><span class="line">        Thread proxy = <span class="keyword">new</span> Thread(pro);</span><br><span class="line">        <span class="comment">//3&gt;调用.start() 启动线程</span></span><br><span class="line">        proxy.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"主程序的表演"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐使用Runnable创建线程：(面向接口编程)</p><ol><li><p>避免单继承的局限性</p></li><li><p>便于共享资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟购票，实现了购票功能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Web12306</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">50</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//跳出循环，结束线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"抢到了"</span>+num--);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建真实角色</span></span><br><span class="line">        Web12306 web = <span class="keyword">new</span> Web12306();</span><br><span class="line">        <span class="comment">//代理</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(web,<span class="string">"甲"</span>); </span><br><span class="line">        <span class="comment">//"甲" 是Thread.currentThread().getName()，是这个线程的名字</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(web,<span class="string">"乙"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(web,<span class="string">"丙"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>实现Runnable接口来实现多线程的缺点：<strong>1.不能抛异常；2.没有返回值</strong></p><p>通过Callable接口实现多线程：</p><ul><li><p>优点：可以获取返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Callable和Future接口</span><br><span class="line">Callable是类似于Runnable的接口，实现Callable接口和实现Runnable的类都是可被其他线程执行的任务</span><br><span class="line">Callable和Runnable的不同：</span><br><span class="line"> <span class="number">1</span>&gt;Callable规定的方法是call(),而Runnable规定的方法是run()</span><br><span class="line"> <span class="number">2</span>&gt;call()方法可抛出异常,而run()方法不能抛出异常</span><br><span class="line"> <span class="number">3</span>&gt;Callable的任务执行后可返回值，它提供了检查计算是否完成的方法，以待计算的完成，并检索计算的结果</span><br><span class="line">Future表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果，通过Future对象可了解任务执行情况，可取消任务的执行，还可获取任务执行的结果</span><br></pre></td></tr></table></figure></li><li><p>缺点：<strong>繁琐</strong></p></li></ul><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.创建Callable实现类+重写call</span><br><span class="line"><span class="number">2</span>.借助执行调度服务ExecutorService，获取Future对象</span><br><span class="line">  <span class="number">1</span>&gt;ExecutorService ser = Excutors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">  <span class="number">2</span>&gt;Future result = ser.submit(实现类对象);</span><br><span class="line"><span class="number">3</span>.获取值result.get()</span><br><span class="line"><span class="number">4</span>.停止服务ser.shutdownNow()</span><br></pre></td></tr></table></figure><h3 id="模拟龟兔赛跑"><a href="#模拟龟兔赛跑" class="headerlink" title="模拟龟兔赛跑"></a>模拟龟兔赛跑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Race</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">//步</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Race</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Race</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Race</span><span class="params">(String name,<span class="keyword">int</span> time)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            Thread.sleep(time); <span class="comment">//延时</span></span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Callable创建线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testcall</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">        IntereuptedException,ExecutionException</span>&#123;</span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">2</span>); <span class="comment">//数字代表创建几个线程</span></span><br><span class="line">        Race tortoise = <span class="keyword">new</span> Race(<span class="string">"乌龟"</span>,<span class="number">1000</span>);</span><br><span class="line">        Race rabbit = <span class="keyword">new</span> Race(<span class="string">"兔子"</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="comment">//获取值</span></span><br><span class="line">        Future&lt;Integer&gt; result1 = ser.submit(tortoise);</span><br><span class="line">        Future&lt;Integer&gt; result2 = ser.submit(rabbit);</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        tortoise.setFlag(<span class="keyword">false</span>);</span><br><span class="line">        rabbit.setFlag(<span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> num1 = result1.get();</span><br><span class="line">        <span class="keyword">int</span> num2 = result2.get();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"乌龟跑了"</span>+num1+<span class="string">"步"</span>); <span class="comment">//输出结果：step</span></span><br><span class="line">        System.out.println(<span class="string">"兔子跑了"</span>+num2+<span class="string">"步"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//停止服务</span></span><br><span class="line">        ser.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p>创建之后是新生状态，调用start方法之后进入就绪状态，CPU调度到之后进入运行状态，在时间片内完成了任务就进入死亡状态，没有执行完就进入挂起(就绪状态)</p><p>线程状态：</p><ul><li>新生状态：用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态(runnable)</li><li>就绪状态：处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列，等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，他就会从等待执行状态进入执行状态，系统挑选的动作称之为”CPU调度“。一旦获取CPU，线程就进入运行状态并自动调用自己的run方法</li><li>运行状态：在运行状态的线程执行自己的run方法中的代码，直到调用其他方法而终止、或等待某资源而阻塞或完成任务而死亡。如果在给定的时间片内没有执行结束，就会被系统给换下来回到等待执行状态</li><li><strong>阻塞状态</strong>：处于运行状态的线程在某些情况下，如执行了sleep(睡眠)方法，或等待IO设备等资源，将让出CPU并暂时停止自己的运行，进入到阻塞状态。在阻塞状态的线程不能就如就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等到的IO设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行</li><li>死亡状态：死亡状态是线程生命周期中的最后一个阶段。线程死亡的原因有两个。一个是正常运行的线程完成了它全部的工作，另一个是线程被强制性的终止，如通过执行stop或destory方法来终止一个线程(不推荐使用这两个方法。前者会产生异常，后者是强制终止，不会释放锁)</li></ul><h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><ol><li><p>自然终止：线程体正常执行完毕</p></li><li><p>外部干涉：通过改变标识，来结束循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Study</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.线程类中定义线程体使用的标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//2.线程体使用该标识</span></span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">"study thread……"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.对外提供改变标识的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Study s = <span class="keyword">new</span> Study();</span><br><span class="line">        <span class="keyword">new</span> Thread(s).start();</span><br><span class="line">        <span class="comment">//4.外部干涉</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">50</span> == i)&#123;</span><br><span class="line">                s.stop();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"main……"</span>+i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h1><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>join：合并线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Join</span> <span class="keyword">extends</span> <span class="title">Thread</span> <span class="title">throws</span> <span class="title">InterruptedException</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Join j = <span class="keyword">new</span> Join();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(j); <span class="comment">//新生</span></span><br><span class="line">        t.start(); <span class="comment">//就绪</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//CPU调度到了就运行</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">50</span> == i)&#123;</span><br><span class="line">                t.join() <span class="comment">//main停下来，等待t执行完，再执行。</span></span><br><span class="line">                <span class="comment">//main阻塞了</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"join……"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"main……"</span>)+i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>yield：暂停当前正在执行的线程对象，并执行其他线程，static</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yield</span> <span class="keyword">extends</span> <span class="title">Thread</span> <span class="title">throws</span> <span class="title">InterruptedException</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Join j = <span class="keyword">new</span> Join();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(j); <span class="comment">//新生</span></span><br><span class="line">        t.start(); <span class="comment">//就绪</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//CPU调度到了就运行</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">20</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//Thread.yield()是静态方法，写在谁的线程体里面就暂停谁</span></span><br><span class="line">                <span class="comment">//暂停本线程：main</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"yield……"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"main……"</span>)+i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>每一个对象都有一把锁，这个对象占用了资源，获得了这个资源的一把排他锁(互斥锁)，其他的线程访问不了这个对象</p><p>sleep：暂停线程多少时间，在指定的毫秒数内进行休眠。休眠的时候不释放锁</p><p>sleep一般用于两种形式：1&gt;与时间相关：倒计时   2&gt;模拟网络延时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//倒数10个数，，一秒内打印一个</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sleep</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">System.out.println(num--);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>); <span class="comment">//休眠main</span></span><br><span class="line"><span class="keyword">if</span>(num&lt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//倒计时</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sleep</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//System.currentTimeMillis()+10*1000</span></span><br><span class="line">        <span class="comment">//上面这个代表当前时间的后10秒</span></span><br><span class="line">        <span class="comment">//new date()也可以代表当前时间</span></span><br><span class="line">Date endTime = <span class="keyword">new</span> Date(System.currentTimeMillis()+<span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">long</span> end = endtime.getTime();</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"mm:ss"</span>).format(endTime));</span><br><span class="line"><span class="comment">//等待1秒</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//构建下一秒的时间</span></span><br><span class="line">endTime = <span class="keyword">new</span> Date(endTime.getTime()-<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//10秒以内继续否则退出</span></span><br><span class="line"><span class="keyword">if</span>(end-<span class="number">10000</span>&gt;endTime.getTime())&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟网络延时</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sleep</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//真实角色</span></span><br><span class="line">        Web12306 web = <span class="keyword">new</span> Web12306();</span><br><span class="line">        <span class="comment">//代理</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(web,<span class="string">"甲"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(web,<span class="string">"乙"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(web,<span class="string">"丙"</span>);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Web12306</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">//run方法不能对外声明异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//run方法不能对外声明异常,只能try、catch</span></span><br><span class="line">                <span class="comment">//并发，资源冲突</span></span><br><span class="line">                <span class="comment">//输出结果会出现0和-1，由于并发或资源冲突</span></span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"抢到了"</span>+num--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_class_start</title>
      <link href="/2019/08/28/java/class/start/"/>
      <url>/2019/08/28/java/class/start/</url>
      
        <content type="html"><![CDATA[<h4 id="包装类、装箱、拆箱、时间类、文件类"><a href="#包装类、装箱、拆箱、时间类、文件类" class="headerlink" title="包装类、装箱、拆箱、时间类、文件类"></a><center>包装类、装箱、拆箱、时间类、文件类</center></h4><a id="more"></a><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>包装类的作用：将基本类型包装成对象</p><p>主要介绍一下Integer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer.MAX_VALUE; <span class="comment">//查看int类型的范围的最大值</span></span><br><span class="line">Integer.toHexString(); <span class="comment">//转化为8进制</span></span><br><span class="line">Integer.parseInt(); <span class="comment">//强转为Integer对象</span></span><br><span class="line"><span class="keyword">new</span> Integer(); <span class="comment">//强转为Integer对象</span></span><br><span class="line">Integer.intValue(); <span class="comment">//强转为真正的数字</span></span><br><span class="line">String str = <span class="number">234</span>+<span class="string">""</span>; <span class="comment">//将数字转为字符串</span></span><br></pre></td></tr></table></figure><h1 id="自动装箱、拆箱"><a href="#自动装箱、拆箱" class="headerlink" title="自动装箱、拆箱"></a>自动装箱、拆箱</h1><p>自动装箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">1000</span>; <span class="comment">//jdk5.0以前这样写是错的</span></span><br><span class="line"><span class="comment">//之后有了自动装箱，编译器帮我们改进代码,变成了如下的样子：</span></span><br><span class="line"><span class="comment">//Integer a = new Integer(1000);</span></span><br><span class="line"><span class="comment">//a还是对象</span></span><br></pre></td></tr></table></figure><p>自动拆箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="keyword">new</span> Integer(<span class="number">1500</span>); <span class="comment">//jdk5.0以前这样写是错的</span></span><br><span class="line"><span class="comment">//编译改进：new Integer(1500).intValue();</span></span><br><span class="line"></span><br><span class="line">Integer b = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">int</span> c = b; <span class="comment">//编译改进：b.intValue();</span></span><br><span class="line"><span class="comment">//如果 b=null ，编译器会报java.lang.NullPointerException</span></span><br><span class="line"><span class="comment">//表面上没有调用任何方法，实际上调用了b的intValue() b是空，就会报空指针</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>装箱的时候：-128到127之间的数依然被认为是基本数据类型</p><p>这样做的目的是提高效率</p><h1 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h1><p>java.util.Date 是个核心</p><p>java.text.DataFormat 它是个父类 ，看一下它的子类(实现类)：java.text.SimpleDateFormat</p><p>java.text.SimpleDateFormat的作用：把时间对象和字符串做转化</p><p>java.util.Calendar：日期计算</p><p>java.util.GregorianCalendar：是Calendar的子类，公立计算</p><p>开始学习java.util.Date:</p><ul><li>在标准的java类库中包含了一个Date类。他的对象表示特定的瞬间，精确到毫秒</li><li>java中时间表示的说白了也是数字，是从：标准纪元1970.1.1 0点开始到某个时刻的毫秒数，类型是long</li></ul><h2 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h2><p>SimpleDateFormat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.currentTimeMillis(); <span class="comment">//得到当前时间</span></span><br><span class="line">format</span><br><span class="line">parse</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 hh:mm:ss,属于本年的低w周"</span>); </span><br><span class="line"><span class="comment">//这个规定了输出格式</span></span><br><span class="line"></span><br><span class="line">Date d = <span class="keyword">new</span> Date(<span class="number">123213123L</span>);</span><br><span class="line">String str = df.format(d);</span><br><span class="line">System.out.println(str); <span class="comment">//1970年01月02日</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"1977-7-7"</span>;</span><br><span class="line"><span class="comment">//必须要有格式化，还得和上面的字符串相对应</span></span><br><span class="line">DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Date d = df.parse(str);</span><br><span class="line">    System.out.println(d);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h2><p>GregorianCalendar</p><p>月份：一月是0，二月是1，以此类推，12月是11</p><p>星期：星期日是一，星期六是七</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Calendar c = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">    c.set(<span class="number">2001</span>,Calendar.FEBRUARY,<span class="number">10</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>);</span><br><span class="line">    Date d = c.getTime();</span><br><span class="line">    System.out,println(d);</span><br><span class="line">    <span class="comment">//输出结果：Sat Feb 10 12:23:34 CST 2001</span></span><br><span class="line">    <span class="comment">//可以添加天数或者月数</span></span><br><span class="line">    <span class="comment">//前面是类型，后面是数量</span></span><br><span class="line">    c.add(Calendar.YEAR,<span class="number">30</span>);</span><br><span class="line">    <span class="comment">//想减的话就把30换成-30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="file"><a href="#file" class="headerlink" title="file"></a>file</h1><p>java.io.File：文件和目录路径名的抽象表现形式</p><p>通过File对象可以访问文件的属性</p><p>通过File对象创建空文件或目录(在该对象所指的文件或目录不存在的情况下)</p><p>file里面有很多的方法，可以精确的操作某个文件，可以去网上百度一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"d:/src/TestObject.java"</span>);</span><br><span class="line">f.createNewFile(); <span class="comment">//创建文件</span></span><br><span class="line">f.delete(); <span class="comment">//删除文件</span></span><br><span class="line">f.isFile(); <span class="comment">//判断是不是文件</span></span><br><span class="line">f.isDirectory(); <span class="comment">//判断是不是目录</span></span><br><span class="line">f.mkdirs(); <span class="comment">//创建目录</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_string_start</title>
      <link href="/2019/08/27/java/string/start/"/>
      <url>/2019/08/27/java/string/start/</url>
      
        <content type="html"><![CDATA[<h4 id="string、ArrayList、多维数组"><a href="#string、ArrayList、多维数组" class="headerlink" title="string、ArrayList、多维数组"></a><center>string、ArrayList、多维数组</center></h4><a id="more"></a><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>String是不可变字符序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String是不可变的字符序列，有不一样的字符一定是在方法区中新建了一个</span></span><br><span class="line"><span class="comment">//但是String gh;这样的话，gh是一个变量，里面的引用地址可以改变</span></span><br><span class="line"><span class="comment">//看一下源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span></span><br><span class="line"><span class="class">     <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,<span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,<span class="title">CharSequence</span></span>&#123;</span><br><span class="line">     <span class="comment">//它是一个常量，会出现在方法区中，且唯一确定</span></span><br><span class="line">     <span class="comment">//这就是String是不可变字符序列的与原因，出现不一样的字符一定是方法区中新建了一个</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">charAt(); <span class="comment">//查看索引位置对应的字符</span></span><br><span class="line">equals(); <span class="comment">//比较内容是否相同</span></span><br><span class="line">indexOf(); <span class="comment">//查看某个字符的索引位置</span></span><br><span class="line">substring(<span class="number">0</span>); <span class="comment">//从某个内容开始截取字符串，直到末尾</span></span><br><span class="line">split(); <span class="comment">//切割字符串</span></span><br><span class="line">trim(); <span class="comment">//去掉首尾空格</span></span><br><span class="line">replace(); <span class="comment">//替换掉某个字符</span></span><br><span class="line">length(); <span class="comment">//长度，length是数组的属性，但是我们不能直接用，因为人家是私有的，只能通过方法来用</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">equalsIgnoreCase(); <span class="comment">//忽略大小写，比较内容是否相同</span></span><br><span class="line">lastIndexOf(); <span class="comment">//该字母在字符串中最后出现的索引位置</span></span><br><span class="line">startWith(); <span class="comment">//判断是不是以传入的字符串开头的</span></span><br><span class="line">endWith(); <span class="comment">//判断是不是以传入的字符串结尾的</span></span><br><span class="line">toLowerCase(); <span class="comment">//转为小写</span></span><br><span class="line">toUpperCase(); <span class="comment">//转为大写</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们要避免下面的代码，创建对象太多，代码效率低</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String gh = <span class="string">"a"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * String gh = new String("a"); //这一步生成两个对象</span></span><br><span class="line"><span class="comment">         * 这样的话执行下面的过程会生成12个对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//gh所指向的地址可以不断发生变化</span></span><br><span class="line">            <span class="comment">//但是每执行一次，会在方法区中生成一个新的String类型的常量，</span></span><br><span class="line">            <span class="comment">//这个时候gh指向了这个常量，通过gh得到的值，就是这个新创建的String类型的常量</span></span><br><span class="line">            <span class="comment">//gh是一个局部变量，存放在栈中</span></span><br><span class="line">            gh += i;</span><br><span class="line">            <span class="comment">//一共创建了11个对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(gh);</span><br><span class="line">        <span class="comment">//输出结果：a0123456789</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><p>StringBuilder出现的意义：防止项目中多次操作String，创建太多对象，代码效率低。如果必须要创建很多的对象的话，又想要提升代码效率，那么StringBuilder应运而生。StringBuilder只创建一个对象，它使用了<strong>扩容机制</strong>，一开始会创建长度为16的数组，长度不足会自动扩容 value.length*2+2 ，这里会生成新数组，回收旧数组。这样的话就解决了String的字符串不可变序列的问题。StringBuilder就是可变的字符串序列。</p><p>StringBuilder创建新对象的时候，会自动给一个16位的数组，如果新建的时候有字符串。那么会给一个字符串.长度+16位的数组</p><p><strong>String是不可变字符序列，StringBuilder是可变字符序列(注意源码分析)</strong></p><p>StringBuilder和StringBuffer基本上是一样的</p><ul><li>StringBuilder是线程不安全的，效率高，我们一般用这个</li><li>StringBuffer是线程安全的，效率较低</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以通过retuen this来实现方法链，看下面：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> StringBuilder(<span class="string">"a"</span>);</span><br><span class="line">s.append(<span class="keyword">true</span>).append(<span class="number">321</span>).append(<span class="string">"随便"</span>); <span class="comment">//这个就称之为方法链</span></span><br><span class="line"><span class="comment">//append是追加的意思</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        StringBuilder gh = <span class="keyword">new</span> StringBuilder(<span class="string">"a"</span>);</span><br><span class="line">        <span class="comment">//这样的话只需要创建两个对象</span></span><br><span class="line">        <span class="comment">//第一个："a"</span></span><br><span class="line">        <span class="comment">//第二个：new StringBuilder("a")</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//1000个数组长度不够用，扩容机制</span></span><br><span class="line">            <span class="comment">//append()自带扩容：value.length*2+2;</span></span><br><span class="line">            <span class="comment">//但是数组一旦确定长度就不能改变了，为了解决这个问题</span></span><br><span class="line">            <span class="comment">//它做了一件事：创建了一个新数组，把旧数组放了进去</span></span><br><span class="line">            <span class="comment">//把旧的数组根据垃圾回收机制回收</span></span><br><span class="line">            gh.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringBuilder中的一些方法"><a href="#StringBuilder中的一些方法" class="headerlink" title="StringBuilder中的一些方法"></a>StringBuilder中的一些方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">append(); <span class="comment">//拼接</span></span><br><span class="line">delete(); <span class="comment">//根据索引位置删除数组中的元素，删头不删尾，(3,5)删的是索引为3，4的元素</span></span><br><span class="line">replace(); <span class="comment">//取代</span></span><br><span class="line">insert(); <span class="comment">//插入</span></span><br><span class="line">reverse(); <span class="comment">//反转</span></span><br></pre></td></tr></table></figure><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>StringBuffer的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">//比StringBuilder多了一个synchroized</span></span><br><span class="line">    <span class="comment">//这个涉及到了线程安全</span></span><br><span class="line">    <span class="comment">//除了这个，StringBuilder和StringBuffer没有任何区别，继承的同一个类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.trimToSize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模拟ArrayList容器"><a href="#模拟ArrayList容器" class="headerlink" title="模拟ArrayList容器"></a>模拟ArrayList容器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//value = new Object[16];</span></span><br><span class="line">        <span class="comment">//一个构造器调用另一个构造器</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArriayList</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        value = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        value[size] = obj;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">if</span>(size &gt;= value.length)&#123;</span><br><span class="line">            <span class="comment">//装不下了。进行扩容</span></span><br><span class="line">            <span class="keyword">int</span> newCapacity = value.length*<span class="number">2</span>;</span><br><span class="line">            Object[] newList = <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">            <span class="comment">//System.arraycopy(src,srcPos,dest,destPos,length);</span></span><br><span class="line">            <span class="comment">//这段代码可以将旧数据的数据拷贝到新数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++)&#123;</span><br><span class="line">                newList[i] = value[i];</span><br><span class="line">            &#125;</span><br><span class="line">            value = newList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(); <span class="comment">//手动抛出异常，异常地抛出代表程序的停止</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> value[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组初始化的三种方式：</p><p>默认初始化：默认初始化为类型的默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]; <span class="comment">//默认值：0，0</span></span><br><span class="line"><span class="keyword">boolean</span>[] b = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>]; <span class="comment">//默认值：false，fales</span></span><br><span class="line">String[] s = <span class="keyword">new</span> String[<span class="number">2</span>]; <span class="comment">//默认值：null，null</span></span><br></pre></td></tr></table></figure><p>静态初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> class <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;; <span class="comment">//这个就是静态初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]; <span class="comment">//动态初始化数组，先分配空间</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//给数组元素赋值</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">//给数组元素赋值</span></span><br></pre></td></tr></table></figure><p>多维数组：自己理解一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line"><span class="keyword">int</span> a[][] = <span class="keyword">new</span> <span class="keyword">int</span>[][<span class="number">3</span>]; <span class="comment">//错误，</span></span><br><span class="line"><span class="comment">//第一个方括号内没值，第二个方括号内不能有值</span></span><br></pre></td></tr></table></figure><p>数组copy：</p><p>System类里包含了一个static void arraycopy(object src,int srcpos,object dest,int destpos,int length)方法，该方法可以将src数组里面的元素赋值给dest数组的元素，其中srcpos指定从src数组的第几个元素开始赋值，length参数指定将src数组的多个元素赋给dest数组的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] s = &#123;<span class="string">"Mircosoft"</span>,<span class="string">"IBM"</span>,<span class="string">"Oracle"</span>,<span class="string">"Apple"</span>&#125;;</span><br><span class="line">String[] sBak = <span class="keyword">new</span> String[<span class="number">6</span>];</span><br><span class="line"><span class="comment">//将s中的元素copy到sBak里面</span></span><br><span class="line">System.arraycopy(s,<span class="number">0</span>,sBak,<span class="number">0</span>,s.length);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(); <span class="comment">//为数组排序</span></span><br><span class="line">Arrays.toString(); <span class="comment">//打印数组</span></span><br><span class="line">Arrays.fill(a,<span class="number">2</span>,<span class="number">4</span>,<span class="number">100</span>); <span class="comment">//将2到4索引的元素替换为100</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_object_end</title>
      <link href="/2019/08/26/java/object/end/"/>
      <url>/2019/08/26/java/object/end/</url>
      
        <content type="html"><![CDATA[<h4 id="多态深入、抽象类、接口、回调、内部类"><a href="#多态深入、抽象类、接口、回调、内部类" class="headerlink" title="多态深入、抽象类、接口、回调、内部类"></a><center>多态深入、抽象类、接口、回调、内部类</center></h4><a id="more"></a><h1 id="多态的内存分析"><a href="#多态的内存分析" class="headerlink" title="多态的内存分析"></a>多态的内存分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HttpServlet.service()"</span>);</span><br><span class="line">        <span class="comment">//它调用了doGet()</span></span><br><span class="line">        doGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HttpServlet.doGet()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HttpServlet.doPost()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyServlet.doGet()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        HttpServlet s = <span class="keyword">new</span> MyServlet();</span><br><span class="line">        s.service();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果：</span></span><br><span class="line"><span class="comment">         * HttpServlet.Service()</span></span><br><span class="line"><span class="comment">         * MyServlet.doGet()</span></span><br><span class="line"><span class="comment">         */</span>     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这个为什么会这样呢？</p><p>调用的时候总是会优先调用子类的构造方法，从子类的构造器开始向上寻找构造器，直到找到Object的构造器，开始向下执行构造器。</p><p>但是我们执行方法的时候，先寻找子类中是否存在该方法，不存在的话会向上寻找，一旦找到就会执行了，如果父类调用了某个方法，这个时候很特殊。由于this指的是当前对象(的地址)，指的还是子类对象，所以还是从子类中开始找。</p><p>咱们的例子：先在MyServlet中找service()，但是找不到，向上找，在HttpServlet中找到了，执行的时候service中执行了doGet()。因为this的原因，执行doGet的时候，又会重复一开始的操作，从MyServlet开始找，找到了，直接执行MyServlet的doGet()方法</p><h1 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类(abstract)"></a>抽象类(abstract)</h1><p>抽象类就是有抽象方法的类：抽象方法就是只有声明，没有实现</p><p>抽象类是一种模板模式。抽象类为所有子类提供了一个通用模板，子类可以在这个模板基础上进行扩展。</p><p>通过抽象类，可以避免子类设计的随意性。通过抽象类，我们就可以做到严格控制子类的设计，使子类之间更加通用</p><p>要点：</p><ul><li>有抽象方法的类只能定义成抽象类</li><li>抽象类不能实例化，不能使用new来实例化抽象类</li><li>抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能被子类调用</li><li>抽象类只能用来继承</li><li>抽象方法必须被子类实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">//包含了抽象方法的类一定是抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//能这么调的原因：abstract不能被实例化，调用的run()是子类的</span></span><br><span class="line">    <span class="comment">//抽象类只能用来继承</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"呼吸"</span>);</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了Animal抽象类，就必须实现抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫步"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把设计和实现分开了,将方法的设计和方法的实现分开了</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>interface，更加抽象，抽象类的抽象类。接口是最抽象的，接口里面放的就是基本不变的东西，以不变应万变</p><p>这个的目的就是，<strong>设计和实现分离</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义的时候用interface，除了定义的时候没有任何区别</span></span><br><span class="line"><span class="comment">//还是java文件，编译之后还是class文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="comment">//接口里面只有：常量和抽象方法</span></span><br><span class="line">    <span class="comment">//public static final有没有都一样，系统会自动加上的</span></span><br><span class="line">    <span class="comment">/*public static final*/</span>String MAX_GREAD = <span class="string">"Boss"</span>;</span><br><span class="line">    <span class="keyword">int</span> MAX_SPEED = <span class="number">120</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法必须是public，不加的话，系统自动加public abstract</span></span><br><span class="line">    <span class="comment">/*public abstract*/</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//怎么实现接口？</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myclass</span> <span class="keyword">implements</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="comment">//implements：实现</span></span><br><span class="line">    <span class="comment">//没有什么可以集成的，只要自己实现就行，不需要extends</span></span><br><span class="line">    MyInterface.MAX_GREAD; <span class="comment">//调用接口中的常量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 两个抽象方法必须都实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyClass.test1()"</span>);</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类可以实现多个接口，但是一个类只能继承一个父类</p><p>java class不支持多继承，但是接口可以多继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口是有多继承的</span></span><br><span class="line"><span class="comment">//接口可以多继承，因为接口足够简单</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceC</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span>,<span class="title">InterfaceB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">InterfaceC</span></span>&#123;</span><br><span class="line">    <span class="comment">//必须实现三个方法，InterfaceC继承的接口，这个类也得实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口即规范</p><h1 id="回调的实现"><a href="#回调的实现" class="headerlink" title="回调的实现"></a>回调的实现</h1><p>CallBack/Hook/模板方法模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个类模拟回调</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaintFrame</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawFrame</span><span class="params">(MyFrame f)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"启动线程"</span>);</span><br><span class="line">        System.out.println(<span class="string">"增加循环"</span>);</span><br><span class="line">        System.out.println(<span class="string">"查看消息线"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//回调</span></span><br><span class="line">        f.paint();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"启动缓存，增加效率"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        drawFram(<span class="keyword">new</span> GameFrame01());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 输出结果：</span></span><br><span class="line"><span class="comment">         * 启动线程</span></span><br><span class="line"><span class="comment">         * 增加循环</span></span><br><span class="line"><span class="comment">         * 查看消息线</span></span><br><span class="line"><span class="comment">         * GameFrame01.Paint() //子类引用指向父类对象</span></span><br><span class="line"><span class="comment">         * 启动缓存，增加效率</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyFrame.Paint()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameFrame01</span> <span class="keyword">extends</span> <span class="title">MyFrame</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GameFrame01.Paint()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * java中的画窗口的实现类似于这个过程</span></span><br><span class="line"><span class="comment"> * 你不需要调用你写的画窗口的类，但他就直接相当于钩子执行了</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>innerclasses</p><p>一般情况，我们把类定义成独立的单元。有些情况下，我们把一个类放在另一个的内部定义，称为内部类</p><p>内部类的作用：</p><ul><li>内部类提供了更好的封装。只能让外部类直接访问，不允许同一个包下的其他类直接访问</li><li>内部类可以直接访问外部类的私有属性，内部类被当作其外部类的成员。但外部类不能访问内部类的内部属性</li></ul><p>内部类的使用场合：</p><p>由于内部类提供了更好的封装性，并且可以很方便的访问外部类的属性。所以，通常内部类在只为所在外部类提供服务的情况下优先使用</p><h2 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h2><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>就好像外部类的成员一样</p><p>可以使用private、protected、public 任意进行修饰。</p><p><strong>外部类文件：外部类.class</strong></p><p><strong>内部类文件：外部类$内部类.class</strong></p><h4 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h4><p>普通成员，外部类里使用非静态内部类和平时使用其他类没什么不同</p><ul><li><p>非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象，那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象</p></li><li><p>非静态内部类可以使用外部类的成员，但是外部类不能直接访问非静态内部类成员</p></li><li><p>非静态内部类不能有静态方法、静态属性、静态初始化块</p></li><li><p>静态成员不能访问非静态成员：外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例</p></li><li><p>成员变量访问要点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.内部类里的方法的局部变量：变量名</span><br><span class="line"><span class="number">2</span>.内部类的属性：<span class="keyword">this</span>.变量名</span><br><span class="line"><span class="number">3</span>.外部类的属性：外部类类名.<span class="keyword">this</span>.变量名</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Face</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nose</span></span>&#123;</span><br><span class="line">        String type;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"呼吸"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//内部类和外部类中都有type，怎么调用外部类的type</span></span><br><span class="line">            System.out.println(Face.<span class="keyword">this</span>.type);</span><br><span class="line">            <span class="comment">//如果内部类中没有type的话，想调用外部类的type，直接调用就行了</span></span><br><span class="line">            System.out.println(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>内部类的访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.外部类中定义内部类：newInnerClass()</span><br><span class="line"><span class="number">2</span>.外部类以外的地方使用非静态内部内：</span><br><span class="line">  Outer.inner varname = OuterObject.new Inner();</span><br><span class="line">    Face.Nose nose = <span class="keyword">new</span> Face().new Nose();</span><br><span class="line">    Face f2 = <span class="keyword">new</span> Face();</span><br><span class="line">    Face.Nose nose2 = f2.new Nose();</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Face</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nose</span></span>&#123;</span><br><span class="line">        String type;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"呼吸"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Face f = <span class="keyword">new</span> Face();</span><br><span class="line">        <span class="comment">//创建内部类的对象,但是得通过外部类来new</span></span><br><span class="line">        <span class="comment">//鼻子的存在，必须先有一张脸</span></span><br><span class="line">        Nose n = f.new Nose();</span><br><span class="line">        Face.Nose n1 = f.new Nose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态成员</p><p>使用要点：</p><ul><li><p>当一个静态内部类对象存在，并不一定存在对应的外部类对象。因此，静态内部类的实例方法/属性不能直接访问外部类的实例方法/属性</p></li><li><p>静态内部类看做外部类的一个静态成员。因此，外部类的方法中可以通过：静态内部类.名字 来访问静态内部类的静态成员。通过new静态内部类()访问静态内部类的实例</p></li><li><p>在外部类的外面创建静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Face.TestStaticInner aInner = <span class="keyword">new</span> Face.TestStaticInner();</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Face</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">static</span> String color;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ear</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这个里面不能调用外部的type，因为外部类中不一定有</span></span><br><span class="line">        <span class="comment">//静态内部类和外部类在堆中是两个类的存在</span></span><br><span class="line">        <span class="comment">//非静态内部类和外部类在堆中是一个类的存在，有非静态内部类必定有外部类</span></span><br><span class="line">        <span class="comment">//所以非静态内部类可以直接调用外部类的属性和方法</span></span><br><span class="line">        </span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="comment">//但是如果外部类中的属性是static的话，就可以直接调用</span></span><br><span class="line">           System.out.println(color);</span><br><span class="line">           System.out.println(<span class="string">"听"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Face</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ear</span></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"听"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 非静态内部类</span></span><br><span class="line"><span class="comment">         * Face f = new Face();</span></span><br><span class="line"><span class="comment">         * //创建内部类的对象,但是得通过外部类来new</span></span><br><span class="line"><span class="comment">         * //鼻子的存在，必须先有一张脸</span></span><br><span class="line"><span class="comment">         * Nose n = f.new Nose();</span></span><br><span class="line"><span class="comment">         * Face.Nose n1 = f.new Nose();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//可以直接创建对象，不需要Face对象</span></span><br><span class="line">        Face.Ear e = <span class="keyword">new</span> Face.Ear();</span><br><span class="line">        e.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>适合那种只需要使用一次的类。比如：键盘监听操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类构造器(实参列表) 实现接口()&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名内部类类体</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addWindowListener(<span class="keyword">new</span> WindowAdapter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span></span>&#123;</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.addKeyListener(<span class="keyword">new</span> KeyAdapter()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(KeyEvent e)</span></span>&#123;</span><br><span class="line">        <span class="comment">//TODO Auto-generated method atub</span></span><br><span class="line">        myTank.keyPressed(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyReleased</span><span class="params">(KeyEvent e)</span></span>&#123;</span><br><span class="line">        <span class="comment">//TODO Auto-generated method stub</span></span><br><span class="line">        myTank.KeyReleased(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义在方法内部。作用域只限于本方法。用的非常少</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_object_next</title>
      <link href="/2019/08/24/java/object/next/"/>
      <url>/2019/08/24/java/object/next/</url>
      
        <content type="html"><![CDATA[<h4 id="对象的三大特征，数组"><a href="#对象的三大特征，数组" class="headerlink" title="对象的三大特征，数组"></a><center>对象的三大特征，数组</center></h4><a id="more"></a><h1 id="对象三大特征"><a href="#对象三大特征" class="headerlink" title="对象三大特征"></a>对象三大特征</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承让我们更加容易实现类的扩展。</p><p>从字面意思理解extend的意思是扩展。子类是父类的扩展。现实世界中的继承无处不在。</p><p>如何实现代码重用？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExtends</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"休息一会"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    String major;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学习两小时"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"休息一会"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个Student和上面的Student是一样的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String major;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学习两小时"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承的使用要点：</p><ul><li>父类也称作超类、基类、派生类等</li><li>Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护</li><li>java中类没有多继承，接口有多继承</li><li>子类继承父类，可以得到父类的全部属性和方法(除了父类的构造方法)，但不见得可以直接访问(比如，父类私有属性和方法)</li><li>如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object</li></ul><h3 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h3><p>instanceof是二元运算符，左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu2 <span class="keyword">instanceof</span> Student</span><br><span class="line">stu2 <span class="keyword">instanceof</span> Person</span><br><span class="line">stu2 <span class="keyword">instanceof</span> Object</span><br></pre></td></tr></table></figure><h3 id="方法重写override"><a href="#方法重写override" class="headerlink" title="方法重写override"></a>方法重写override</h3><p>子类通过重写父类的方法，可以用自身的行为替换父类的行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOverride</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Horse h = <span class="keyword">new</span> Horse();</span><br><span class="line">        h.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"停止"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> <span class="keyword">extends</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="comment">//子类重写、覆盖了父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"四蹄翻飞，嘚嘚嘚"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法重写需要符合下面三个要点：</p><ul><li>“==”：方法名、形参列表相同</li><li>“&lt;=”：返回值类型和声明异常类型，子类小于等于父类</li><li>“&gt;=”：访问权限，子类大于等于父类</li></ul><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>Object类是所有java类的根基类，也就意味着所有的java对象都拥有Object类的属性和方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TestObject to = <span class="keyword">new</span> TestObject();</span><br><span class="line">        <span class="comment">//打印to和打印to.toString是一样的</span></span><br><span class="line">        <span class="comment">//他有这个方法是因为它继承了Object类</span></span><br><span class="line">         System.out.println(to);</span><br><span class="line">         System.out.println(to.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写toString</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"测试Object对象"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Object类的toString方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一部分是包下的类名，第二部分是堆中的地址</span></span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="和equals方法"><a href="#和equals方法" class="headerlink" title="==和equals方法"></a>==和equals方法</h3><p>“==”代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象</p><p>Object类中定义有：public boolean equals(Object obj)方法，提供定义“对象内容相等”的逻辑</p><p>Object中的equals方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="comment">//看地址是否相同，看是不是同一个对象</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String中重写了equals方法，比较的是String中的值是否相同</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSuper</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChildClass.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FatherClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value = <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">"FatherClass.value = "</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">FatherClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.f(); <span class="comment">//调用父类对象的普通方法</span></span><br><span class="line">        value = <span class="number">200</span>;</span><br><span class="line">        System.out.println(<span class="string">"ChildClass.value = "</span>+value);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.value); <span class="comment">//调用父类对象的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出结果：</span></span><br><span class="line"><span class="comment"> * FatherClass.value = 100</span></span><br><span class="line"><span class="comment"> * ChildClass.value = 200</span></span><br><span class="line"><span class="comment"> * 200</span></span><br><span class="line"><span class="comment"> * 100</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>使用super调用普通方法，语句没有位置限制，可以在子类中随便调用</p><p>若是构造方法的第一行代码没有显式调用super或者this；那么java默认都会调用super()，含义是调用父类无参数的构造方法。这里super()可以省略</p><h4 id="这里涉及到了继承树的追溯"><a href="#这里涉及到了继承树的追溯" class="headerlink" title="这里涉及到了继承树的追溯"></a>这里涉及到了继承树的追溯</h4><p>属性/方法查找顺序：</p><ul><li>查找当前类中有没有属性h</li><li>依次上溯每个父类，查看每个父类中是否有h，直到Object</li><li>如果没有找到，则出现编译错误</li><li>上面步骤，只要找到h变量，则这个过程终止</li></ul><p>构造方法调用顺序：</p><p>构造方法第一句总是：super()来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化和构造方法</p><p>注：静态初始化块调用顺序，与构造方法调用顺序一样，不再重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSuper</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始创建一个ChildClass对象……"</span>);</span><br><span class="line">        <span class="keyword">new</span> ChildClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FatherClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FatherClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建FatherClass"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">FatherClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建ChildClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出结果：</span></span><br><span class="line"><span class="comment"> * 开始创建一个ChildClass对象……</span></span><br><span class="line"><span class="comment"> * 创建FatherClass</span></span><br><span class="line"><span class="comment"> * 创建ChildClass</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>步骤：第一步是向上找，第二步是向下执行</strong></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装的含义：我们程序设计要追求“高内聚、低耦合”，高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用</p><p>编程中封装的具体优点：</p><ul><li>提高代码的安全性</li><li>提高代码的复用性</li><li>“高内聚”：封装细节，便于修饰内部代码，提高可维护性</li><li>“低耦合”：简化外部调用，便于调用者使用，便于扩展和协作</li></ul><h3 id="封装的实现"><a href="#封装的实现" class="headerlink" title="封装的实现"></a>封装的实现</h3><p>封装的实现：使用访问控制符</p><p>java使用“访问控制符”来控制哪些细节需要封装，哪些细节需要暴露。java四种访问控制符：private、default、protected、public，他们说明了面向对象的封装性，所以我们用他们尽可能的让访问权限降到最低，从而提高安全性</p><p>java四种访问控制符：</p><ul><li>private表示私有，只有自己的类能访问</li><li>default表示没有访问修饰符，只有同一个包的类能访问</li><li>protected表示可以被同一个包的类以及其他包中的子类访问</li><li>public表示可以被该项目的所有包中的所有类访问</li></ul><h3 id="封装的使用细节"><a href="#封装的使用细节" class="headerlink" title="封装的使用细节"></a>封装的使用细节</h3><p>类的属性的处理：</p><ul><li>一般使用private访问权限</li><li>提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作</li><li>一些只用于本类的辅助性方法可以用private修饰，希望其他类调用方法用public修饰</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(age &gt;= <span class="number">1</span> &amp;&amp; age &lt;= <span class="number">130</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"请输入正常人的年龄"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态指的是同一个方法调用，由于对象不同可能会有不同的行为。现实生活中，同一个方法，具体实现会完全不同</p><p>多态的要点：</p><ul><li>多态是方法的多态，不是属性的多态(多态与属性无关)</li><li>多态的存在要有三个必要条件：继承，方法重写，父类引用指向子类对象</li><li>父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPolym</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        animalCry(a); <span class="comment">//执行结果：叫了一声</span></span><br><span class="line">        Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">        animalCry(d); <span class="comment">//执行结果：汪汪汪</span></span><br><span class="line">        <span class="comment">//多态开始出现了，父类引用指向了子类对象</span></span><br><span class="line">        <span class="comment">//传的是狗就会调用狗的构造方法，传的是猫就会调用猫的构造方法</span></span><br><span class="line">        <span class="comment">//这就是多态，非常方便</span></span><br><span class="line">        <span class="comment">//Animal d = new Dog(); 实际上还是狗</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">animalCry</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">        a.shout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"叫了一声"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪汪汪"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"喵喵喵"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象的转型-casting"><a href="#对象的转型-casting" class="headerlink" title="对象的转型(casting)"></a>对象的转型(casting)</h3><p>父类引用指向子类对象，我们称这个过程为向上转型，属于自动类型转换(子类可以自动转换成父类)</p><p>向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要进行类型的强制转换，我们称之为向下转型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPolym</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> class <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal d = <span class="keyword">new</span> Dog(); <span class="comment">//自动向上转型</span></span><br><span class="line">        Animal c = <span class="keyword">new</span> Cat(); </span><br><span class="line">        </span><br><span class="line">        Dog d2 = (Dog)d; <span class="comment">//强制向下转型</span></span><br><span class="line">        Dog d3 = (Dog)c; <span class="comment">//编译时不会报错，但是运行的时候会出现 </span></span><br><span class="line">         <span class="comment">//XX cannot be cast to XX 的错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"叫了一声"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪汪汪"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"喵喵喵"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>fianl关键字的作用：</p><ul><li><p>修饰变量：被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> MAX_SPEEO = <span class="number">120</span>;</span><br></pre></td></tr></table></figure></li><li><p>修饰方法：该方法不可被子类重写。但是可以重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//重载是方法名相同，参数类型、参数个数不同</span></span><br><span class="line"><span class="comment">//重写是子类重写父类的方法，参数列表和返回类型都必须相同</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法重载是一个类中定义了多个方法名相同，而他们的参数的数量不同或类型不同，则称之为方法的重载</span></span><br><span class="line"><span class="comment"> * 方法重写是再子类存在方法与父类的方法的名字相同，而且参数个数与类型一样的方法，则称之为重写</span></span><br><span class="line"><span class="comment"> * 方法重载就是一个类的多态性的表现，而方法重写是子类与父类的一种多态性的表现</span></span><br><span class="line"><span class="comment"> /*</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> /**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Override</span>是伪代码，表示重写(当然也可以不写)，他有以下好处</span></span><br><span class="line"><span class="comment">  * 可以当注释用，方便阅读</span></span><br><span class="line"><span class="comment">  * 编译器可以给你验证<span class="doctag">@Override</span>下面的方法名是否是你的父类中所有的，如果没有则会报错。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure></li><li><p>修饰类：修饰的不能被继承。比如Math、String等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><p>数组是相同类型数据的有序集合。数组描述的是相同类型的若干数据，按照一定的先后次序组合而成。其中，每一个数据称之为一个元素，每个元素可以通过一个索引(下标)来访问他们</p><p>数组的三个基本特点：</p><ul><li>数组长度是确定的。数组一旦被创建，它的大小就是不可以改变的</li><li>其元素必须是相同类型，不允许出现混合类型</li><li>数组类型可以实任何数据类型，包括基本类型和引用类型</li></ul><p>数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量</p><h2 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h2><p>注意事项：</p><ul><li>声明的时候没有实例化任何对象，只有在实例化数组对象时，JVM才分配空间，这时才与长度有关</li><li>声明一个数组的时候并没有数组真正被创建</li><li>构造一个数组，必须指定长度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建基本类型的一维数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> class <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] s = <span class="keyword">null</span>; <span class="comment">//声明数组</span></span><br><span class="line">        s = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//给数组分配空间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            s[i] = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">//给数组元素赋值</span></span><br><span class="line">            System.out.println(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>数组初始化方式共有三种：静态初始化、动态初始化、默认初始化</p><p>静态初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> class <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;; <span class="comment">//这个就是静态初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]; <span class="comment">//默认值：0，0</span></span><br><span class="line"><span class="keyword">boolean</span>[] b = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>]; <span class="comment">//默认值：false，fales</span></span><br><span class="line">String[] s = <span class="keyword">new</span> String[<span class="number">2</span>]; <span class="comment">//默认值：null，null</span></span><br></pre></td></tr></table></figure><p>动态初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]; <span class="comment">//动态初始化数组，先分配空间</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//给数组元素赋值</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">//给数组元素赋值</span></span><br></pre></td></tr></table></figure><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>数组元素下标的合法空间：[0,length-1].我们可以通过下标来遍历数组中的元素，遍历时可以读取元素的值或者修改元素的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arge)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//初始化数组元素的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">            a[i] = <span class="number">100</span>*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取元素的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for-each循环"></a>for-each循环</h3><p>增强for循环，for-each是JDK1.5新增加的功能，专门用于读取数组或集合中的所有元素，即对数组进行遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String[] ss = &#123;<span class="string">"aa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>,<span class="string">"ddd"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(String temp : ss)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_object_start</title>
      <link href="/2019/08/22/java/object/start/"/>
      <url>/2019/08/22/java/object/start/</url>
      
        <content type="html"><![CDATA[<h4 id="对象和类、内存分析、垃圾回收机制、构造器-this-、static、参数传值机制、包机制、import"><a href="#对象和类、内存分析、垃圾回收机制、构造器-this-、static、参数传值机制、包机制、import" class="headerlink" title="对象和类、内存分析、垃圾回收机制、构造器(this)、static、参数传值机制、包机制、import"></a><center>对象和类、内存分析、垃圾回收机制、构造器(this)、static、参数传值机制、包机制、import</center></h4><a id="more"></a><p>面向过程和面向对象</p><p>面向过程和面向对象都是对软件分析、设计和开发的一种思想，它指导着人们以不同的方式去分析、设计和开发软件</p><p>面向过程思想思考问题时，我们首先思考“怎么按步骤实现？”并将步骤对应成方法，一步一步，最终完成。这个适合简单任务，不需要过多协作的情况下。比如：如何开车</p><p>面向过程适合简单、不需要协作的事务。但是当我们思考比较复杂的问题，比如“如何造车”，就会发现列出1234这样的步骤，是不可能的。那是因为，造车太复杂，需要很多协作才能完成。此时面向对象思想就应运而生了</p><p>面向对象：</p><p>OOA：面向对象分析</p><p>OOD：面向对象设计</p><p>面向对象思想更契合人的思维模式。我们首先思考的是“怎么设计这个事务？”。比如思考造车，我们就会先思考“车怎么设计？”，而不是“怎么按照步骤造车的问题”</p><p>面向对象和面向过程的总结</p><ul><li>都是解决问题的思维方式，都是代码组织的方式</li><li>解决简单问题可以使用面向过程</li><li>解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。方法和控制语句就是典型的面向过程的产物</li></ul><p>对象就是一个内存块，包含了很多的数据</p><p>事物的发展总是遵循“量变引起质变”的哲学原则；企业管理和数据管理、甚至社会管理也有很多共通的地方</p><p>对象进化史(数据管理和企业管理共通之处)：</p><ul><li>数据无管理时代：数据量很少，数据不需要进行管理</li><li>数据管理和企业部门制：数据量增加，把同类型的数据放在一起。于是数组诞生了</li><li>对象和企业项目制：项目组就是一个小公司，类似于我们的对象，对象包含了不同类型的数据。</li></ul><h1 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h1><p>类可以看作是对象的模板，或者图纸，系统根据类的定义来造出对象</p><p>类：我们叫做class。</p><p>对象：我们叫做Object，instance(实例)。以后我们说某个类的对象，某个类的实例。是一样的意思</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性(field，或者叫成员变量)：属性用于定义该类或该对象包含的数据或者说静态特征，属性作用范围是整个类体，在定义成员变量时可以对其初始化，java使用默认的值对其初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>光有属性没有方法在c语言中叫<strong>结构体</strong></p><p>方法用来定义该类实例的行为特征。方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数，面向过程中，函数是基本单位，整个程序由一个个的函数调用组成，面向对象中，整个程序的基本单位是类，方法是属于类和对象的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我在学习"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我在玩游戏"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main方法是程序执行的入口，必须要有滴</p><h2 id="典型的类"><a href="#典型的类" class="headerlink" title="典型的类"></a>典型的类</h2><p>new：代表创建一个对象</p><p>new调用了类的构造方法，通过构造方法创建了这个对象</p><p>构造方法：用来创建这个类的对象。无参的构造方法可以由系统自动创建</p><p>一个java文件可以写多个类，但是每个java文件只能有一个public修饰的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Computer computer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我正在使用"</span>+computer.brand+<span class="string">"牌子的电脑学习"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        <span class="comment">//学生要想有电脑，首先得new一个电脑</span></span><br><span class="line">        computer.brand = <span class="string">"战神"</span>;</span><br><span class="line">        text text = <span class="keyword">new</span> text();</span><br><span class="line">        text.computer = computer;</span><br><span class="line">        text.study();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    String brand = <span class="string">"神州"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象内存分析"><a href="#面向对象内存分析" class="headerlink" title="面向对象内存分析"></a>面向对象内存分析</h1><p>java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈的特点描述如下</p><ul><li>栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等)</li><li>JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等)</li><li>栈属于线程私有，不能实现线程间的共享</li><li>栈的存储特性是“先进后出，后进先出”，先进去的不能先出来被后面进来的挡住了</li><li>栈是由系统自动分配，速度快！栈是一个连续的内存空间</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆的特点如下：</p><ul><li>堆用于存储创建好的对象和数组(数组也是对象)</li><li>JVM只有一个堆，被所有的线程共享</li><li>堆是一个不连续的内存空间，分配灵活，速度慢</li></ul><h2 id="方法区-静态区"><a href="#方法区-静态区" class="headerlink" title="方法区(静态区)"></a>方法区(静态区)</h2><ul><li>JVM只有一个方法区，被所有线程共享</li><li>方法区实际也是堆，只是用于存储类、常量的相关信息</li><li>用来存放程序中永远不变或唯一的内容。(类信息Class对象、静态变量、字符串常量等)</li></ul><h2 id="执行一个java文件"><a href="#执行一个java文件" class="headerlink" title="执行一个java文件"></a>执行一个java文件</h2><p>第一步：javac 类.java 生成.class文件，交给JRE</p><p>第二步：java 类名 ，交给底层操作系统</p><p>先在方法区存储类的相关信息：1.代码 2.静态变量 3.静态方法 4.字符串常量 。这个执行完之后相当于第二部执行完了。</p><p>然后就会去找main方法，找到main方法之后会在栈中为main方法开辟一块栈帧</p><p>碰到new之后，先为构造方法开辟一块栈帧，构造器执行完成之后会在堆中创建一块内存来存放对象，每个对象都会有一个地址。main方法中的对象名就会等于这个地址，以后再引用对象名的时候会直接指向堆内存地址去操作这个对象，栈帧和堆中的内存有了一种联系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//computer 这是一个局部变量，会存放在main方法的栈帧中</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      new Computer()会传回堆中的内存地址，</span></span><br><span class="line"><span class="comment">      之后操作computer的时候都会直接操作堆中的内存。</span></span><br><span class="line"><span class="comment">      堆中的内存中存放着Computer对象的属性和方法，</span></span><br><span class="line"><span class="comment">      这样的话就可以直接调用Computer对象的属性和方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>垃圾回收机制(Garbage Collection)</p><p>java引入了垃圾回收机制，令c++程序员最头疼的内存管理问题迎刃而解，java程序员可以将更多的精力放到业务逻辑上而不是内存管理的工作上，大大的提高了开发效率</p><h2 id="垃圾回收要做的事情"><a href="#垃圾回收要做的事情" class="headerlink" title="垃圾回收要做的事情"></a>垃圾回收要做的事情</h2><ol><li>发现无用的对象</li><li>回收无用对象占用的内存空间</li></ol><p>垃圾回收机制保证可以将“无用的对象”进行回收。无用的对象指的是没有任何变量引用该对象，java的垃圾回收器通过相关的算法发现无用对象，并进行清楚和整理</p><h2 id="垃圾回收的相关算法"><a href="#垃圾回收的相关算法" class="headerlink" title="垃圾回收的相关算法"></a>垃圾回收的相关算法</h2><ol><li>引用计数法：堆中每个对象都有一个引用计数，被引用一次，计数加一，被引用变量的值变为null，则计数减一，直到计数为零，则表示变成无用的对象，优点是算法简单，缺点是“循环引用无用对象”无法被识别，意思就是两个对象互相引用的话，他们的计数就都是1，不可能出现零，无法判断他们是不是无用的对象</li><li>引用可达法：(根搜索算法)程序把所有的引用关系看作是一张图，从一个节点GC、ROOT开始，寻找对应的应用节点，找到这个节点之后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</li></ol><h2 id="通用的分代垃圾回收机制"><a href="#通用的分代垃圾回收机制" class="headerlink" title="通用的分代垃圾回收机制"></a>通用的分代垃圾回收机制</h2><p>分代垃圾回收机制，是基于这样的一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象采用不同的回收算法，以便提高效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将对内存划分为Eden(年轻代)、Survivor(年轻代)、Tenured/Old(年老代)空间</p><p>持久代是在方法区里</p><h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><p>所有新生成的对象首先都是放在Eden区。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次Minor GC会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间，当年轻代区域存放满对象后，就将对象存放到年老带区域</p><h3 id="年老代"><a href="#年老代" class="headerlink" title="年老代"></a>年老代</h3><p>在年轻代中经历了N(默认为15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代和年老代区域</p><h3 id="持久代"><a href="#持久代" class="headerlink" title="持久代"></a>持久代</h3><p>用于存放静态文件，如java类、方法等。持久代对垃圾回收没有显著的影响</p><p>程序在持久代中的对象就在</p><p>Minor GC：用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同的，同一时刻Survivor1和Survivor2只有一个在用，一个为空)</p><p>Major GC：用于清理老年代区域</p><p>Full GC：用于清理年轻代、年老代区域。成本较高，会对系统性能产生影响</p><h3 id="垃圾回收过程"><a href="#垃圾回收过程" class="headerlink" title="垃圾回收过程"></a>垃圾回收过程</h3><ol><li>新创建的对象，绝大多数都会存储在Eden中</li><li>当Eden满了(达到一定比例)不能再创建新对象，则触发垃圾回收(Minor GC)，将无用的对象清理掉，然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区</li><li>当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空</li><li>重复多次(默认为15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中</li><li>当Old区满了，则会触发一个一次完整的垃圾回收(FullGC)，之前新生代大垃圾回收称为(minorGc)</li></ol><h2 id="JVM调优和Full-GC"><a href="#JVM调优和Full-GC" class="headerlink" title="JVM调优和Full GC"></a>JVM调优和Full GC</h2><p>在对JVM调优的过程中，很大一部分工作就是对于Full Gc的调节。有如下原因可能导致Full GC：</p><ul><li>年老代(Tenured)被写满</li><li>持久代(Perm)被写满</li><li>System.gc()被显式调用(这里是程序建议GC启动，不是调用GC)</li><li>上一次GC之后Heap的各域分配略动态变化</li></ul><h1 id="开发中很容易造成内存泄露的操作"><a href="#开发中很容易造成内存泄露的操作" class="headerlink" title="开发中很容易造成内存泄露的操作"></a>开发中很容易造成内存泄露的操作</h1><p>如下四种情况最容易造成内存泄漏：</p><h2 id="1-创造大量无用对象"><a href="#1-创造大量无用对象" class="headerlink" title="1.创造大量无用对象"></a>1.创造大量无用对象</h2><p>比如我们在大量拼接字符串时，使用了String而不是StringBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">    str += i; <span class="comment">//相当于产生了10000个String对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-静态集合类的使用"><a href="#2-静态集合类的使用" class="headerlink" title="2.静态集合类的使用"></a>2.静态集合类的使用</h2><p>像HashMap、Vector、List等的使用最容易出现内存泄漏，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放</p><h2 id="3-各种连接对象-IO流对象、数据库连接对象、网络连接对象-未关闭"><a href="#3-各种连接对象-IO流对象、数据库连接对象、网络连接对象-未关闭" class="headerlink" title="3.各种连接对象(IO流对象、数据库连接对象、网络连接对象)未关闭"></a>3.各种连接对象(IO流对象、数据库连接对象、网络连接对象)未关闭</h2><p>IO流对象、数据库连接对象、网络连接对象等连接对象属于物理连接，和硬盘或者网络连接，不实用的时候一定要关闭</p><h2 id="4-监听器的使用"><a href="#4-监听器的使用" class="headerlink" title="4.监听器的使用"></a>4.监听器的使用</h2><p>释放对象时，没有删除相应的监听器</p><p>要点：</p><ul><li>程序员无权调用垃圾回收器</li><li>程序员可以调用System.gc()，该方法只是通知JVM，并不是运行垃圾回收器。尽量少用，会申请启动Full GC，成本高，影响系统性能</li><li>finalize方法，是java提供给程序员用</li></ul><h1 id="面向对象的基础知识"><a href="#面向对象的基础知识" class="headerlink" title="面向对象的基础知识"></a>面向对象的基础知识</h1><h2 id="构造器-构造方法"><a href="#构造器-构造方法" class="headerlink" title="构造器(构造方法)"></a>构造器(构造方法)</h2><p>构造器也叫构造方法(constructor)，用于对象的初始化</p><p>要点：</p><ul><li>通过new关键字调用</li><li>构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能再构造器里使用return返回某个值</li><li>如果我们没有定义构造器，则编译器会自动的定义一个无参的构造函数。如果已定义则编译器不会自动添加</li><li>构造器的方法名必须和类名一致</li></ul><p>构造方法的重载</p><p>构造方法的第一句总是supper(); 就算你没加，系统会自动帮你添加</p><p>this表示创建好的对象</p><ul><li>来释放对象或资源的方法，但尽量少用</li></ul><h2 id="对象创建的过程和this的本质"><a href="#对象创建的过程和this的本质" class="headerlink" title="对象创建的过程和this的本质"></a>对象创建的过程和this的本质</h2><p>构造方法是创建java对象的重要途径，通过new关键字调用构造器，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。</p><p>创建一个对象分为以下四步：</p><ul><li>分配对象空间，并将对象成员变量初始化为0或空</li><li>执行属性值的显式初始化</li><li>执行构造方法</li><li>返回对象的地址给相关变量</li></ul><p>this的本质就是“创建好的对象地址” 由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象”</p><p>this最常的用法：</p><ul><li><p>在程序中产生二义性之处，应使用this来指明当前对象；普通方法中，this总是指向调用该方法的对象。构造方法中，this总指向正要初始化的对象</p></li><li><p>使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TestThis(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line">TestThis(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)&#123;</span><br><span class="line">    <span class="keyword">this</span>(a,b); <span class="comment">//必须放在第一句</span></span><br><span class="line">    <span class="keyword">this</span>.c = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>this不能用于static方法中，因为this指的是当前对象。但是所有的静态方法和静态类都在方法区内，方法区内存放的是类信息，而不是对象信息</li></ul><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>在类中，用static声明的成员变量，也称为类变量，类变量的生命周期和类相同，在整个应用程序执行期间都有效</p><p>静态变量的特点：</p><ol><li>为该类的公用变量，属于类，被该类的所有实例所共享，在类被载入时被显式初始化</li><li>对于该类的所有对象来说，static成员变量只有一份，被该类的所有对象共享</li><li>一般用“类名.类属性/方法”来调用(也可以通过对象引用或类名访问静态成员)</li><li>在static方法中不可直接访问非static的成员</li></ol><p>核心要点：</p><p>static修饰的成员变量和方法，从属于类</p><p>普通变量和方法式从属于对象的</p><h3 id="静态初始化块"><a href="#静态初始化块" class="headerlink" title="静态初始化块"></a>静态初始化块</h3><p>构造方法用于对象的初始化。静态初始化块，用于类的初始化操作，在静态初始化块中不能直接访问非static成员</p><p>注意事项：</p><ol><li>上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止</li><li>构造方法执行顺序和上面的顺序一致</li></ol><h2 id="参数传值机制"><a href="#参数传值机制" class="headerlink" title="参数传值机制"></a>参数传值机制</h2><p>java中，方法中所有参数都是“值传递”，也就是“传递的是值的副本”。也就是说，我们得到的是“原参数的复印件，而不是原件”。因此，复印件改变不会影响原件。</p><h3 id="基本数据类型参数的传值"><a href="#基本数据类型参数的传值" class="headerlink" title="基本数据类型参数的传值"></a>基本数据类型参数的传值</h3><p>传递的是副本。副本改变不会影响原件</p><h3 id="引用类型参数的传值"><a href="#引用类型参数的传值" class="headerlink" title="引用类型参数的传值"></a>引用类型参数的传值</h3><p>传递的是值的副本，但是引用类型指的是“对象的地址”。因此，副本和原参数都指向了同一个地址，改变副本指向地址对象的值，也意味着原参数指向对象的值也发生了改变</p><h2 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h2><p>包机制是java中管理类的重要手段。开发中，我们会遇到大量同名的类，通过包我们很容易解决类重名的问题，也可以实现对类的有效管理。包对于类，相当于文件夹对于文件的作用</p><p>我们通过package实现对类的管理，package有两个要点：</p><ol><li>通常是类的第一句非注释性语句</li><li>包名：域名倒着写即可，再加上模块名，便于内部管理类</li></ol><p>注意事项：</p><ol><li>写项目的时候都要加包，不要使用默认包</li><li>com.gao和com.gao.car，这两个包没有包含关系，是两个完全独立的包。只是逻辑上看起来后者是前者的一部分</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.test;  <span class="comment">//一定要是非注释性语句的第一句</span></span><br><span class="line"><span class="keyword">package</span> cn.*; <span class="comment">//导入包下的所有类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接通过类名来调用。否则就需要书写类的完整包名和类名。import后，便于编写代码，提高可维护性</p><p>注意要点：</p><ol><li>java会默认导入java.lang包下的所有类，因此这些类我们可以直接使用</li><li>如果导入两个同名的类，只能用包名+类名来显示调用相关类</li></ol><p>同一个包下面两个类互相创建对象，不需要进行导入包，就可以创建对象</p><p>在不同包下的两个类不能互相创建对象，只能导入包，或者在包名之下写类名</p><h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h3><p>静态导入(static import)是在JDK1.5之后新增加的功能，其作用是用于导入指定类的静态属性，这样我们可以直接使用静态属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*; <span class="comment">//导入Math类的所有静态属性和方法</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.PI;  <span class="comment">//导入Math类的PI属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(PI);</span><br><span class="line">        System.out.println(random());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_next</title>
      <link href="/2019/08/20/java/basis/next/"/>
      <url>/2019/08/20/java/basis/next/</url>
      
        <content type="html"><![CDATA[<h4 id="java类型转换、控制语句、语句块、递归"><a href="#java类型转换、控制语句、语句块、递归" class="headerlink" title="java类型转换、控制语句、语句块、递归"></a><center>java类型转换、控制语句、语句块、递归</center></h4><a id="more"></a><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>自动类型转化指的是容量小的数据类型可以自动转换为容量大的数据类型</p><p>容量不是按字节算的：</p><p>long 8 byte</p><p>float 4 byte</p><p>但long类型的值可以自动转为float，因为float表示的范围要比long类型大，但是转的时候会损失一定的精度</p><p><img src="/images/typechange.png" alt="红色的可以自动转，蓝色的转的时候会损失精度"></p><p>特例：</p><p>可以将整形常量直接赋值给byte、short、char等类型变量，而不需要进行强制类型转换，只需要不超过其表数范围即可</p><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>强制类型转化，又称为造型，用于显式的转换一个数值的类型。在有可能丢失信息的情况下进行的转换是通过造型来完成的，但可能造成精度降低或溢出</p><p>运算符()中的type表示将值var想要转换成的目标数据类型</p><p>注意：</p><ul><li>操作比较大的数时，要留意是否溢出</li><li>不要命名名字为l的变量，小写l容易与1混淆</li><li>举个例子：只要有一个long类型的数，则经过运算之后结果为long类型的数。</li></ul><h1 id="使用Scanner获取键盘输入"><a href="#使用Scanner获取键盘输入" class="headerlink" title="使用Scanner获取键盘输入"></a>使用Scanner获取键盘输入</h1><p>需要导包java.util.Scanner</p><p>测试获得键盘的输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"输入你的名字："</span>);</span><br><span class="line"></span><br><span class="line">String name = scanner.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"请输入你的爱好："</span>)；</span><br><span class="line"></span><br><span class="line">String favor = scanner.nextInt();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"请输入你的年龄："</span>)；</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age = scanner.nextInt();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"###########"</span>);</span><br><span class="line">Syetem.out.println(name);</span><br><span class="line">System.out.println(favor);</span><br><span class="line">System.out.println(age);</span><br></pre></td></tr></table></figure><h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p>流程控制语句是用来控制程序中个语句执行的顺序</p><ul><li>顺序结构：代表先执行a，在执行b的逻辑</li><li>选择结构：代表 如果……，则……的逻辑</li><li>循环结构：代表 如果……，则……再继续的逻辑</li></ul><p>任何软件和程序，小到一个练习，大到一个操作系统，本质上都是由变量、选择语句、循环语句组成</p><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><h3 id="if单选择结构"><a href="#if单选择结构" class="headerlink" title="if单选择结构"></a>if单选择结构</h3><ul><li>如果if语句不写{}，则只能作用于后面的第一条语句</li><li>强烈建议，任何时候都写上{}，即使里面只有一句话</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">TestIf</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d = Math.random(); <span class="comment">//返回0-1之间的随机数，不包含1</span></span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>)(<span class="number">6</span>*Math.random()+<span class="number">1</span>); <span class="comment">//生成1-6之间的随机数</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"小"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if-else双选择结构"><a href="#if-else双选择结构" class="headerlink" title="if-else双选择结构"></a>if-else双选择结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestItElse</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = (<span class="keyword">int</span>)(<span class="number">6</span>*Math.random()+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(h &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"小"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"大"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if-else-if-else多选择结构"><a href="#if-else-if-else多选择结构" class="headerlink" title="if-else if-else多选择结构"></a>if-else if-else多选择结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch多选择结构"><a href="#switch多选择结构" class="headerlink" title="switch多选择结构"></a>switch多选择结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        语句序列<span class="number">1</span>;</span><br><span class="line">        [<span class="keyword">break</span>];</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        语句序列<span class="number">1</span>;</span><br><span class="line">        [<span class="keyword">break</span>];</span><br><span class="line">    [<span class="keyword">default</span>:</span><br><span class="line">        默认语句;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[代表可选]</span></span><br><span class="line"><span class="comment">//switch语句会根据表达式的值从相匹配的case标签处开始执行，一直执行到break语句处或者是switch语句末尾。如果表达式的值与任一case不匹配，则进入default语句(如果存在default语句的情况)</span></span><br></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>循环结构分两大类：一类是当型、一种是直到型</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do-while:先执行后判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span>(i &lt;= <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Sum = "</span>+sum);</span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//i++就是所谓的迭代</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"sum = "</span>+sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过,可以隔开多个初始化语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = i + <span class="number">10</span>; i &lt; <span class="number">5</span>; i++,j = i*<span class="number">2</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"i = "</span>+i+<span class="string">"j = "</span>+j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化变量作用域：只在for循环内部</p><h2 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h2><p>嵌套循环：在一个循环语句内部再嵌套一个或多个循环，称之为嵌套循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            System.out.print(j+<span class="string">"*"</span>+i+<span class="string">"="</span>+i*j+<span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i+=<span class="number">2</span>)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"100以内奇数的和："</span>+sum);</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">100</span>; i+=<span class="number">2</span>)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"100以内偶数的和："</span>+sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.print(i+<span class="string">"\t"</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><p>break用于强制退出循环，不执行循环中剩余的语句</p><p>continue退出本次循环，继续下一次</p><p>goto关键字很早就在程序设计语言中出现。尽管goto仍然是java的一个保留字，但并未在java语言中得到正式使用；Java没有goto语句</p><p>带标签的break和continue，我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，他们就会中断到存在标签的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//打印101到150之间的所有质数</span></span><br><span class="line">    outer: <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">101</span>; i &lt; <span class="number">150</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h1><p>语句块(有时叫做复合语句)，是用花括号扩起的任意数量的简单java语句。块确定了局部变量的作用域。块中的程序代码，作为一个整体，是要被一起执行的。块可以被嵌套在另一个块中，但是不能在两个嵌套的块内声明同名的变量。语句块可以使用外部的变量，而外部不能使用语句块中的变量，因为语句块中定义的变量作用域只限于语句块</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法说白了就是给代码块加了一个名字，可以被我们反复的调用</p><p>方法就是一段用来完成特定功能的代码片段，类似于其他语言的函数</p><p>方法用于定义该类的实例的行为特征和功能的实现。方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。<strong>面向对象中，整个程序的基本单位是类</strong>，方法是从属于类和对象的</p><p>方法是可以传参数的，想打印啥，你就给他传啥，他就会按照你的意愿去打印</p><h3 id="方法的详细说明"><a href="#方法的详细说明" class="headerlink" title="方法的详细说明"></a>方法的详细说明</h3><ul><li>形式参数：在方法声明时用于接受外界传入的数据</li><li>实参：调用方法时实际传给方法的数据</li><li>返回值：方法在执行完毕后返回给调用它的环境数据</li><li>返回值类型：实现约定的返回值的数据类型，如无返回值，必须显示指定的void</li></ul><p>方法中return的两个作用：</p><ol><li>结束该方法</li><li>返回返回值</li></ol><p>注意事项：</p><ul><li>实参的数目、数据类型、次序必须和所调用的方法声明的形式参数列表匹配</li><li>return语句终止方法的执行并指定要返回的数据</li><li>java中进行方法调用中传递参数时，遵循<strong>值传递</strong>的原则(传递的都是数据的副本)</li><li>基本类型传递的是该数据值的copy值</li><li>引用类型传递的是该对象引用的copy值，但指向的是同一个对象</li></ul><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>overload</p><p>重载的方法，实际上是完全不同的方法，只是名称相同而已</p><p>重载的方法，形参个数或者类型不同</p><p>参数名称不同，不能构成重载</p><p>返回值类型不同，不能构成重载，这两种情况无法区分</p><h2 id="递归结构"><a href="#递归结构" class="headerlink" title="递归结构"></a>递归结构</h2><p>递归是一种常见的解决问题的方法，即把问题逐渐简单化。递归的基本思想就是“自己调用自己”，一个使用递归技术的方法会直接或者间接的调用自己</p><p>利用递归可以用简单的程序来解决一些复杂的问题。</p><p>递归结构包括两个部分：</p><ul><li>定义递归头。解答：什么时候不调用自身的方法。如果没有头，也就是递归的结束条件</li><li>递归体：解答：什么时候需要调用自身的方法</li></ul><p>递归的缺陷：耗时耗力</p><p>注意事项：</p><ul><li>任何使用递归解决的问题也能使用迭代解决，当递归方法可以更加自然的反应问题，并且易于理解和调试，并且不强调效率问题时，可以采用递归</li><li>在高性能的情况下尽量避免使用递归，递归调用既浪费时间，又消耗内存</li></ul><p>爬虫是递归</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_basis_start</title>
      <link href="/2019/08/16/java/basis/start/"/>
      <url>/2019/08/16/java/basis/start/</url>
      
        <content type="html"><![CDATA[<h4 id="标识符、变量、常量、数据类型、运算符"><a href="#标识符、变量、常量、数据类型、运算符" class="headerlink" title="标识符、变量、常量、数据类型、运算符"></a><center>标识符、变量、常量、数据类型、运算符</center></h4><a id="more"></a><h1 id="语言发展史"><a href="#语言发展史" class="headerlink" title="语言发展史"></a>语言发展史</h1><p>机器语言、汇编语言、高级语言</p><h2 id="计算机高级语言的类型"><a href="#计算机高级语言的类型" class="headerlink" title="计算机高级语言的类型"></a>计算机高级语言的类型</h2><p>编译型：c++、c（源码被编译完之后直接给系统）</p><p>解释型：javascript、Python、Php</p><p><em>java是编译型语言和解释型语言的结合（源码文件（.java）被编译为class文件（字节码文件）然后被JRE处理（类加载器、字节码校验器、解释器（虚拟机）））最后JRE给了系统**</em>java–&gt;JVM–&gt;底层操作系统，经过这么一个中介我们java避免了与操作系统直接打交道，这样实现跨平台的核心机制（JRE是java运行时环境，包括了虚拟机JVM）**</p><p>脚本语言：javascript、Python、Php</p><p>编译语言：java</p><p>标记语言：Html、xml</p><h2 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h2><p>安卓开发：<strong>Kotlin</strong></p><p>苹果（IOs）开发：<strong>Objective-C</strong>、<strong>Swift</strong></p><p> <strong>Fortran</strong>世界上第一种高级语言IBM公司提出的</p><p><strong>Basic</strong>、<strong>COBOL</strong>、<strong>Pasacl</strong>都是老一辈的开发语言</p><p><strong>java</strong>：称之为c++-，广泛用于企业级软件开发、安卓移动开发、大数据云计算等领域，几乎涉及IT所有行业。IBM、Oracle、Sun（被Oracle收购）都支持java，形成了一个生态体系，主要是因为Java的开源性。java的优势：跨平台/可移植性、多线程、分布式、高性能、健壮性</p><p><strong>Python</strong>：蟒蛇，又称之为胶水语言（可以和c、c++整合），广泛应用于：图形处理、科学计算、web编程、多媒体应用、引擎开发；尤其是在未来大热方向机器学习和人工智能上有非常大的潜力</p><p><strong>c语言</strong>、<strong>c++</strong>、<strong>c#</strong>都很优秀，所有的语言都是c发展而来的</p><p><strong>php</strong>是世界上最好的语言，用于大型web开发</p><p><strong>javascript</strong>：用于前端页面渲染</p><h1 id="java的运行环境"><a href="#java的运行环境" class="headerlink" title="java的运行环境"></a>java的运行环境</h1><h2 id="JVM、JRE、JDK"><a href="#JVM、JRE、JDK" class="headerlink" title="JVM、JRE、JDK"></a>JVM、JRE、JDK</h2><p>JVM（Java Virtual Machine）：源码经过编译器编程字节码，字节码被JVM解释执行。JVM与操作系统打交道</p><p>JRE（Java Runtime Environment）：包含Java虚拟机、库函数、运行Java应用程序所必须的文件</p><p>JDK（Java Delelopment Kit）：Java开发工具包，包含了JRE，以及增加了<strong>编译器</strong>和<strong>调试器</strong>等用于程序开发的文件</p><p>如果运行Java只需要有JRE就行，开发Java要有JDK</p><p>正是因为有了虚拟机（JVM）我们才实现了跨平台（JVM for Unix、JVM for Windows、JVM for Other）由官方统一给各个系统提供了标准的虚拟机</p><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>bin目录：二进制的exe文件（java（调用虚拟机）、javac（调用编译器））</p><p>db目录：一些数据</p><p>include目录：头文件</p><p>lib目录：库Java的jar包（jar包：字节码文件打包）</p><p>src.zip：java源码的目录</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息</p><h3 id="设置Path环境变量"><a href="#设置Path环境变量" class="headerlink" title="设置Path环境变量"></a>设置Path环境变量</h3><p>运行某个程序的时候，系统会去Path指定的目录中去找这个程序对应的文件</p><h1 id="java标识符、关键字、变常量"><a href="#java标识符、关键字、变常量" class="headerlink" title="java标识符、关键字、变常量"></a>java标识符、关键字、变常量</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符是用来给变量、类、方法以及包进行命名的，如Welcome、main、System、age、name、gender等。标识符需要遵守一定的规则：</p><ul><li>标识符必须以字母、下划线_、美元符号$开头</li><li>标识符其他部分可以是字母、下划线、美元符和数字的任意组合</li><li>java标识符大小写敏感，且长度无限制</li><li>标识符不可以是关键字</li></ul><h3 id="标识符的使用规范"><a href="#标识符的使用规范" class="headerlink" title="标识符的使用规范"></a>标识符的使用规范</h3><ul><li>表示类名的标识符：每个单词的首字母大写，如Man，GoodMan</li><li>表示<strong>方法</strong>和<strong>变量</strong>的标识符：第一个单词小写，从第二个单词开始首字母大写，我们称之为”驼峰原则”，如eat()，eatFood()</li><li>注意：java不采用通常语言使用的ASCII字符集，而是使用Unicode这样标准的国际字符集。因此，这里字母的含义不仅仅是英文，还包括汉字等等。但是不建议大家使用汉字来定义标识符</li></ul><h2 id="关键字-保留字"><a href="#关键字-保留字" class="headerlink" title="关键字/保留字"></a>关键字/保留字</h2><p>java关键字是保留供内部使用的，如class用于定义类。关键字也可以称为保留字，他们的意思是一样的，我们不能使用关键字作为变量名或方法名</p><p><a href="http://cyw3.github.io/YalesonChan/2016/Java-key.html" target="_blank" rel="noopener">关键字详解</a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的本质"><a href="#变量的本质" class="headerlink" title="变量的本质"></a>变量的本质</h3><ul><li>变量的本质上就是代表一个“可操作的存储空间”，空间位置是确定的，但是里面放置什么值不确定。我们可以通过变量名来访问”对应的存储空间“，从而操纵这个”存储空间“存储的值。</li><li>java是一种强类型语言，每个变量都必须声明其数据类型。变量的数据类型决定了变量占据存储空间的大小。比如，int a=3;表示变量a变量的空间大小为4个字节。</li><li>变量作为程序中最基本的存储单元，其要素包括变量名、变量类型和作用域。变量在使用前必须对其声明，只有在变量声明以后，才能为其分配相应长度的存储空间。</li><li>不同的数据类型的常量会在内存中分配不同的空间</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>每个变量都会有类型，类型可以是基本类型，也可以是引用类型</li><li>变量名必须是合法的标识符</li><li>变量声明是一条完整的语句，因此每一个声明都必须以分号结束</li><li>方法中的变量必须声明、赋值之后才可以使用</li></ul><h3 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h3><ul><li><p><strong>局部变量</strong>：方法或语句块内定义的变量。生命周期从声明位置开始到方法语句块执行完毕为止。局部变量在使用前必须先声明、初始化(赋初值)再使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语句块</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> age;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>成员变量</strong>：(实例变量)方法外部、类的内部定义的变量。从属于对象，生命周期伴随着对象始终。如果不自行初始化，他会自动初始化成该类型的默认初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'\u0000'</span>;</span><br><span class="line">boolen = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态变量</strong>：(类变量)方法外部、类的内部定义的变量。使用static定义，从属于类，生命周期伴随类始终，从类加载到卸载(通常系统启动时会把相应的类进行加载，系统结束的时候卸载这些类)，如果不自行初始化，与成员变量相同会自动初始化成该类型的默认初始化值</p></li></ul><h2 id="常量-Constant"><a href="#常量-Constant" class="headerlink" title="常量(Constant)"></a>常量(Constant)</h2><p>常量一旦被赋值就不能被改变</p><p>通过添加关键字final可以将一个变量转变成符号常量</p><p>通常1，2，3，’a’这些称之为字面常量</p><h2 id="变量和常量命名规范"><a href="#变量和常量命名规范" class="headerlink" title="变量和常量命名规范"></a>变量和常量命名规范</h2><ol><li>所有的变量、方法名、类名：见名知义</li><li>类成员变量：首字母小写和驼峰原则：monthSalary</li><li>局部变量：首字母小写和驼峰原则</li><li>常量：大写字母和下划线：MAX_VALUE</li><li>类名：首字母大写和驼峰原则</li><li>方法名首字母小写和驼峰原则</li></ol><h1 id="java数据类型"><a href="#java数据类型" class="headerlink" title="java数据类型"></a>java数据类型</h1><h2 id="数据类型的分类"><a href="#数据类型的分类" class="headerlink" title="数据类型的分类"></a>数据类型的分类</h2><p>基本数据类型：(primitive data type)：</p><ul><li>数值型：byte(1 byte)、short(2 byte)、int(4 byte)、long(8 byte)、float(4 byte)、double(8 byte)</li><li>字符型：char(2 byte)</li><li>布尔型：boolean(1 bit)</li></ul><p>1 byte(字节) = 8 bit(位)</p><p>引用数据类型：(引用对象和变量，4byte)</p><ul><li>类(class)</li><li>接口(interface)</li><li>数组</li></ul><h2 id="整形变量-常量"><a href="#整形变量-常量" class="headerlink" title="整形变量/常量"></a>整形变量/常量</h2><ul><li>byte(1 byte)</li><li>short(2 byte)</li><li>int(4 byte)</li><li>long(8 byte)</li></ul><h3 id="整型常量的四中表示形式"><a href="#整型常量的四中表示形式" class="headerlink" title="整型常量的四中表示形式"></a>整型常量的四中表示形式</h3><ul><li>十进制整数：99</li><li>八进制整数，要求以0开头：015</li><li>十六进制数，要求以0x或0X开头，0x15</li><li>二进制数，要求0b或0B开头，0b01110011</li></ul><p>整型常量默认为int类型，整型常量后面要加L/l才表示这是一个long类型的常量。这里涉及到了类型转换的问题</p><h2 id="浮点变量-常量"><a href="#浮点变量-常量" class="headerlink" title="浮点变量/常量"></a>浮点变量/常量</h2><ul><li>十进制数形式：3.14</li><li>科学计数法形式：314e2(31400)、314E2(31400)、314E-2(3.14)</li></ul><p>浮点常量的默认类型是double，浮点常量后面加F/f表示这是一个float类型的常量</p><p>浮点数是不精确的，一定不要用于比较。如果非要比较，可以引用java.math包下的两个有用类BigInteger、BigDecimal，这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。</p><h2 id="字符型变量-常量"><a href="#字符型变量-常量" class="headerlink" title="字符型变量/常量"></a>字符型变量/常量</h2><p>2 byte</p><p>注意一下转义字符</p><p>看一下String</p><h2 id="布尔类型变量-常量"><a href="#布尔类型变量-常量" class="headerlink" title="布尔类型变量/常量"></a>布尔类型变量/常量</h2><p>占 1 bit</p><p>布尔类型有两个常量值：true和false，不可以使用0或非0整数替代true和false，这点和c语言不同。boolean类型用来判断逻辑条件，一般用于程序流程控制</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="运算符分类-operator"><a href="#运算符分类-operator" class="headerlink" title="运算符分类(operator)"></a>运算符分类(operator)</h2><ul><li>算术运算符</li><li>赋值运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>条件运算符</li><li>字符串连接符</li></ul><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><p>算术运算符中+、-、*、/、%属于二元运算符，二元运算符指的是需要两个操作数才能完成运算的运算符。</p><h4 id="二元运算符的运算规则"><a href="#二元运算符的运算规则" class="headerlink" title="二元运算符的运算规则"></a>二元运算符的运算规则</h4><h5 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h5><ol><li>如果两个操作数有一个为Long，则运算结果也为Long</li><li>没有Long时，结果为int。即使操作数全为short、byte，结果也是int</li></ol><h5 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h5><ol><li>如果有一个数为浮点，则结果为浮点</li><li>如果两个操作数有一个是double，则结果为double</li><li>只有两个操作数都为float，则结果才为float</li></ol><h5 id="取模运算"><a href="#取模运算" class="headerlink" title="取模运算"></a>取模运算</h5><ol><li>其操作数可以为浮点数，一般使用整数，结果是余数，余数符号和左边操作数相同，如7%3=1，-7%3=-1，7%-3=1</li></ol><h2 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h2><p>自增、自减</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = a++; <span class="comment">//执行完后b=3，先给b赋值，再自增</span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line">b = ++a; <span class="comment">//执行完后b=4，a先自增，再给b赋值</span></span><br></pre></td></tr></table></figure><h2 id="赋值运算符及扩展赋值运算符"><a href="#赋值运算符及扩展赋值运算符" class="headerlink" title="赋值运算符及扩展赋值运算符"></a>赋值运算符及扩展赋值运算符</h2><p>赋值运算符：=</p><p>扩展赋值运算符：+=、-=、*=、/=、%=</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a *= b + <span class="number">3</span>; <span class="comment">//相当于a = a * (b + 3)，始终先算后面的结果</span></span><br></pre></td></tr></table></figure><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>==、!=、&gt;、&lt;、&gt;=、&lt;=</p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>=是赋值运算符，而真正的判断两个操作数是否相等的运算符是==</li><li>==、!=是所有(基本类型、引用类型)数据类型都可以使用</li><li>&lt;、&lt;=、&gt;、&gt;= 仅针对数值类型(byte、short、int、long，float、double，以及char)</li></ul><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ul><li>逻辑与：&amp; 操作两个布尔值，两个都是true才是true</li><li>逻辑或：| 操作两个布尔值，有一个是true就是true</li><li>短路与：&amp;&amp; 操作两个布尔值，只要有一个false，就直接返回false</li><li>短路或：|| 操作两个布尔值，只要有一个true，就直接返回true</li><li>逻辑非：! 操作一个布尔值，true就是false</li><li>逻辑异或：^ 操作两个布尔值，两个值相同就是false</li></ul><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul><li><p>~：取反</p></li><li><p>&amp;：按位与 3&amp;4 (0011&amp;0100：0000)</p></li><li><p>|：按位或</p></li><li><p>^：按位异或</p></li><li><p>&lt;&lt;：左移运算符，左移一位相当于乘2</p></li><li><p>(&gt;&gt;)：右移运算符，右移一位相当于除2取商</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="comment">//a的值是12</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="字符串连接符"><a href="#字符串连接符" class="headerlink" title="字符串连接符"></a>字符串连接符</h2><p>+：如果左右两边有一个是字符串，那么+就是字符串连接符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"3"</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> d = <span class="string">'a'</span>;</span><br><span class="line">a + b; <span class="comment">//结果为34</span></span><br><span class="line">a + c; <span class="comment">//结果为35</span></span><br><span class="line">a + b + c; <span class="comment">//345 因为从左到右依次计算</span></span><br><span class="line">b + c + a; <span class="comment">//93</span></span><br><span class="line">d + <span class="number">4</span>; <span class="comment">//101 'a'=97,97+4=101,这里是算术运算符，不是字符串连接符</span></span><br></pre></td></tr></table></figure><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>x:y:z</p><p>其中x为boolean表达式，先计算x的值，若为true，则整个运算结果为表达式y的值。否则整个运算结果为表达式z的值，他是三目运算符</p><h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><p><a href="https://blog.csdn.net/xiaoli_feng/article/details/4567184" target="_blank" rel="noopener">优先级</a></p><h3 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h3><ul><li>不需要去刻意的去记这些优先级，表达式里面有限使用小括号来组织</li><li>逻辑与、逻辑或、逻辑非的优先级：逻辑非&gt;逻辑与&gt;逻辑或</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_jdbc_start</title>
      <link href="/2019/08/16/java/jdbc/start/"/>
      <url>/2019/08/16/java/jdbc/start/</url>
      
        <content type="html"><![CDATA[<h4 id="JDBC全面了解"><a href="#JDBC全面了解" class="headerlink" title="JDBC全面了解"></a><center>JDBC全面了解</center></h4><a id="more"></a><h1 id="JDBC简介"><a href="#JDBC简介" class="headerlink" title="JDBC简介"></a>JDBC简介</h1><ul><li>jdbc是Java Database Connectivity的缩写，即java数据库连接思想，使用jdbc可以实现对数据库的访问</li><li>我们都知道，java是跨操作平台的，而通过jdbc可以实现跨数据库平台，jdbc只是一个抽象的编程接口，通过加载不同的数据库驱动，可以实现不同数据库的通信，例如：Mysql、Oracl、SqlServer</li><li>在java中有两个包java.sql和javax.sql包含jdbc编程的所有接口</li><li>在java中常用接口和类如下：DriverManger 驱动管理器获得数据库链接、Connect 数据库连接接口、Statement 语句接口，用来静态操作SQL语句、PreparedStatement 预定义语句，用来动态操作SQL语句、CallableStatement 可以调用存储过程的预定义语句、ResultSet 结果集，保存数据记录的结果集合、ResultMetaData 结果集元数据，如：列名称、列类型 、DatabaseMetaData 数据库元数据，如：数据库名称、版本</li><li>jdbc的编程步骤：1.加载数据库驱动（jar文件） 2.获取数据库连接 3.创建语句 4.执行查询 5.遍历结果集 6.关闭数据库连接</li></ul><h1 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h1><ul><li>获得数据库连接是操作数据库的第一步，是应用程序和数据库的一个“握手”过程</li><li>数据库打开的连接数是有限的，所以连接使用完成需要关闭</li><li>获得数据库连接的步骤：1.加载驱动(Class.forName) 2.获得连接(DriverManager 是获取数据库连接的一个工厂(实例化的作用) DriverManager.getConnection()) </li></ul><p><strong>创建数据库连接的时候，可以通过配置文件来加载固定格式的url、username、password等</strong></p><h1 id="Statement语句"><a href="#Statement语句" class="headerlink" title="Statement语句"></a>Statement语句</h1><ul><li>Statement语句是SQL语句的描述，使用它可以操作各种SQL语句，包括DDL(数据库定义语句，如创建表)、DML(CRUD)和DCL等</li><li>使用Statement创建表</li></ul><h1 id="ResultSet结果集"><a href="#ResultSet结果集" class="headerlink" title="ResultSet结果集"></a>ResultSet结果集</h1><ul><li>用来获得SQL语句查询结果</li><li>结果集包含了SQL语句的查询结果数据</li><li>调用语句的excuteQuery方法返回结果集对象</li><li><strong>ResultSet常用方法 next：返回boolean类型数据，用来判断结果集中是否有数据   getXXX：获得结果集中的数据项(可以根据列名称、可以根据列索引)</strong></li></ul><h1 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h1><ul><li><p>PreparedStatement为预定义语句，继承Statement</p></li><li><p>Statement只能静态操作SQL语句，如果要操作动态SQL，这里可以使用PreparedStatement来动态操作SQL语句，PreparedStatement通过使用占位符“？”，来预生成SQL语句，从而达到动态操作的功能</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String name,String email)</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"insert into CustomrTbl(name,email) values(?,?);"</span>;</span><br><span class="line">    Connection conn = DBUtil.open();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        PreparedStatement pstmt = conn.prepareStatement(sql);</span><br><span class="line">        pstmt.setString(<span class="number">1</span>,name);</span><br><span class="line">        pstmt.setString(<span class="number">2</span>,email);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        DBUtil.close(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="CallableStatement"><a href="#CallableStatement" class="headerlink" title="CallableStatement"></a>CallableStatement</h1><p>调用后台写好的存储过程</p><ul><li>CallableStatement继承PreParedStatement，提供了调用存储过程的能力</li><li>CallableStatement用法：1.调用简单的存储过程 2.调用有输入参数的存储过程 3.调用有输入、输出参数的存储过程</li><li>实例：1.命令行创建存储过程：create procedure/pro all_customers() select * from CustomerTbl; 2.命令行调用：call all_customers(); 3.使用CallableStatement调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Connection conn = DBUtil.open();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        CallableStatement cstmt = conn.prepareCall(<span class="string">"&#123;call all_customers()&#125;"</span>);</span><br><span class="line">        ResultSet rs = cstmt.executeQuery();</span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            <span class="keyword">int</span> id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">            String name = rs.getString(<span class="number">2</span>);</span><br><span class="line">            String email = rs.getString(<span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">"id:"</span>+id+<span class="string">","</span>+<span class="string">"name:"</span>+name+<span class="string">","</span>+<span class="string">"email:"</span>+email);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这是创建存储过程，in代表输入参数</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_customer(<span class="keyword">in</span> myname <span class="built_in">varchar</span>(<span class="number">20</span>),<span class="keyword">in</span> myemail <span class="built_in">varchar</span>(<span class="number">20</span>)) <span class="keyword">insert</span> <span class="keyword">into</span> CustomerTbl(<span class="keyword">name</span>,email) <span class="keyword">values</span>(myname,myemail);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> getnamebyid(<span class="keyword">in</span> cid <span class="built_in">int</span>,<span class="keyword">out</span> return_name <span class="built_in">varchar</span>(<span class="number">20</span>)) <span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">into</span> return_name <span class="keyword">from</span> CustomerTbl <span class="keyword">where</span> <span class="keyword">id</span> = cid;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Connection conn = DBUtil.open();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        CallableStatement cstmt = conn.prepareCall(<span class="string">"&#123;call getnamebyid(?,?)&#125;"</span>);</span><br><span class="line">        cstmt.setInt(<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//注册输入参数</span></span><br><span class="line">        cstmt.registerOutParameter(<span class="number">2</span>,Types.CHAR);</span><br><span class="line">        cstmt.excute();</span><br><span class="line">        String email = cstmt.getString(<span class="number">2</span>);</span><br><span class="line">        cstmt.executeUpdate();</span><br><span class="line">        System.out.println(email);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">        DBUtil.close(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DAO设计模式"><a href="#DAO设计模式" class="headerlink" title="DAO设计模式"></a>DAO设计模式</h1><ol><li>DAO简介 DAO的全称是：Data Access Object，数据访问对象，使用DAO设计模式，来封装数据库持久层操作(CRUD)，使低级的数据逻辑和高级的业务逻辑分离，达到解耦合的目的</li><li>一个典型的DAO实现有如下的组件：一个DAO接口、数据传输对象(有时称为值对象)、一个实现DAO接口的具体类、一个DAO工厂类</li><li>以维护一个客户信息为例，具体组件如下：CustomerDao接口、Customer值对象(VO)、CustomerDaoImpl(接口工具实现类)、CustomerFactory(工厂类、实例化用)</li></ol><p>Dao接口：里面写很多方法来进行增删改查</p><p>Dao实现类：实现这些方法</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdbc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_mysql_start</title>
      <link href="/2019/08/16/java/mysql/start/"/>
      <url>/2019/08/16/java/mysql/start/</url>
      
        <content type="html"><![CDATA[<h4 id="mysql对数据库和数据表的操作"><a href="#mysql对数据库和数据表的操作" class="headerlink" title="mysql对数据库和数据表的操作"></a><center>mysql对数据库和数据表的操作</center></h4><a id="more"></a><h2 id="mysql操作数据库和数据表"><a href="#mysql操作数据库和数据表" class="headerlink" title="mysql操作数据库和数据表"></a>mysql操作数据库和数据表</h2><p>create table 表名(字段名 类型 主键 非空);   建表</p><p>create database 数据库名;   建库 </p><p>use 数据库名;   使用某个数据库</p><p>show databases：查看数据库</p><p>show tables：查看数据表</p><p>describe/desc 表名：查看表结构</p><p>select * from 表名：查看表内数据</p><h2 id="mysql增删改查"><a href="#mysql增删改查" class="headerlink" title="mysql增删改查"></a>mysql增删改查</h2><p>select * from 表名;   //get</p><p>insert into 表名(字段名) values(字段值);   //post</p><p>update 表名 set 字段名 = ‘字段值’;   //put</p><p>delete from 表名 where id = ‘字段值’;   //delete</p><h2 id="mysql的约束"><a href="#mysql的约束" class="headerlink" title="mysql的约束"></a>mysql的约束</h2><p><strong>primary key主键约束</strong>：是每条信息的唯一信息，主键不能重复，主键禁止为空，主键一般标志到无意义的字段上</p><p><strong>auto_increment自动递增</strong>：从一开始自增</p><p><strong>唯一约束</strong>：约束修饰的字段的不能重复</p><p><strong>非空约束</strong>：<strong>not null</strong>不能为null</p><p><strong>默认约束</strong>：<strong>default</strong>当我们插入字段的时候，如果没有传值，就会使用默认值</p><p><strong>外键约束</strong>：<strong>foreign key</strong> <strong>references</strong></p><p>结论：<em>1.主表中没有的数据，在副表中是不可以使用的</em></p><p>​            <em>2.主表中的记录被副表引用，那么主表中的这条记录是不可以被删除的</em></p><p>涉及到两个表：父表、子表（主表、副表）</p><p><em>主表不能随意删，副表不能随便加</em></p><p>小例子：foreigen key(子表字段名) references 父表(父表中的字段名);</p><h2 id="mysql对时区和密码的操作"><a href="#mysql对时区和密码的操作" class="headerlink" title="mysql对时区和密码的操作"></a>mysql对时区和密码的操作</h2><p>SELECT @@global.time_zone;  // global.time_zone<br>SELECT @@global.system_time_zone;  // globle.system_time<br>show variables like “%time_zone%”;  // Variable_name,Value<br>select now();  // now()</p><p>ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘root’;   修改数据库密码</p><p>select @@autocommit;  mysql的事务开启状态：是否自动提交 1 自动提交 2 非自动提交</p><h2 id="mysql修改表结构："><a href="#mysql修改表结构：" class="headerlink" title="mysql修改表结构："></a>mysql修改表结构：</h2><p><strong>给某个字段添加主键约束</strong>：</p><p>alter table 表名 add primary key(字段名);   //直接增加</p><p>alter table 表名 modify 字段名 类型 primary key; //修改字段间接增加</p><p><strong>删除主键约束</strong>：alter table 表名 <u>drop</u> primary key;</p><p><strong>添加唯一约束</strong>：</p><p>alter table 表名 add unique(字段名);</p><p>alter table 表名 modify 字段名 类型 unique;</p><p><strong>删除唯一约束</strong>：alter table 表名 drop index 字段名;</p><h2 id="设计数据库的格式："><a href="#设计数据库的格式：" class="headerlink" title="设计数据库的格式："></a>设计数据库的格式：</h2><h3 id="第一范式："><a href="#第一范式：" class="headerlink" title="第一范式："></a>第一范式：</h3><p><strong>数据表中的所有字段都是不可分割的原子值</strong></p><p>根据字段值还可以继续拆分的，不满主第一范式</p><p>范式，设计的越详细，对于某些实际操作可能更好，但不一定都是好处</p><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>满足第一范式的前提下，第二范式要求，<strong>除主键外的每一列都必须完全依赖于主键</strong></p><p>如果要出现不完全依赖，只可能发生在联合主键的情况下</p><p>除主键之外的其他列，只依赖与主键的部分字段：<strong>拆表</strong></p><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>必须满足第二范式</p><p><strong>除主键列的其他列之间不能用传递依赖关系</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_mysql_end</title>
      <link href="/2019/08/16/java/mysql/end/"/>
      <url>/2019/08/16/java/mysql/end/</url>
      
        <content type="html"><![CDATA[<h4 id="mysql事务"><a href="#mysql事务" class="headerlink" title="mysql事务"></a><center>mysql事务</center></h4><a id="more"></a><h2 id="mysql事务-1"><a href="#mysql事务-1" class="headerlink" title="mysql事务"></a>mysql事务</h2><p>mysql中，事务其实是一个最小的不可分割的单元，事务能保证一个业务的完整性</p><p>比如我们的银行转账</p><p>a –&gt;-100</p><p>update user set money = money - 10 where name = ‘a’;</p><p>b –&gt;+100</p><p>update user set money = money + 10 where name = ‘b’;</p><p>实际的程序中：如果只有一条语句执行成功，而另外一条没有执行成功出现数据前后不一致</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> money = money - <span class="number">10</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> money = money + <span class="number">10</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'b'</span>;</span><br></pre></td></tr></table></figure><p>多条sql语句，可能会有同时成功的要求，不然的话就同时失败</p><h2 id="mysql如何控制事务："><a href="#mysql如何控制事务：" class="headerlink" title="mysql如何控制事务："></a>mysql如何控制事务：</h2><p>1.mysql默认是开启事务的(自动提交)</p><p>mysql&gt; select @@autocommit;<br>+————–+<br>| @@autocommit |<br>+————–+<br>|            1 |<br>+————–+<br>1 row in set (0.03 sec)</p><p>默认事务开启的作用是：当我们去执行sql语句的时候，效果会立刻体现出来且不能回滚</p><p>create database bank;</p><p>mysql&gt; create table user(<br>    -&gt; id int primary key,<br>    -&gt; name varchar(20),<br>    -&gt; money int<br>    -&gt; );<br>Query OK, 0 rows affected (0.04 sec)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'a'</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>事务回滚：撤销sql语句执行效果</p><p>即使执行了rollback，仍然回不到插入数据之前，说明现在不能回滚，有什么办法可以反悔呢？</p><p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.00 sec)</p><p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1000 |<br>+—-+——+——-+<br>1 rows in set (0.04 sec)</p><p>有什么办法可以反悔呢？</p><p><u><em>设置mysql自动提交为false：*</em>set autocommit = 0;***</u></p><p>上面的操作关闭了mysql的自动提交（commit）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'b'</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+—-+——+——-+<br>2 rows in set (0.03 sec)</p><p>mysql&gt; <u><em>rollback;</em></u><br>Query OK, 0 rows affected (0.01 sec)</p><p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1000 |<br>+—-+——+——-+<br>1 row in set (0.02 sec)</p><p>现在可以取消插入的操作了</p><p>mysql&gt; insert into user values(2,’b’,1000);<br>Query OK, 1 row affected (0.01 sec)</p><p>mysql&gt; <u><em>commit;</em></u><br>Query OK, 0 rows affected (0.00 sec)</p><p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.00 sec)</p><p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+—-+——+——-+<br>2 rows in set (0.03 sec)</p><p>*<u>事务：自动提交 autocommit = 1</u>*</p><p>*<u>手动提交 自己打commit命令</u>*</p><p>*<u>事务回滚 rollback</u>*</p><p>如果说这个时候转账</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> money = money - <span class="number">10</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'a'</span>;                                                                                               </span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> money = money + <span class="number">10</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'b'</span>;</span><br></pre></td></tr></table></figure><p>mysql&gt; update user set money = money - 10 where name = ‘a’;                                                                                               update user set money = money + 10 where name = ‘b’;<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |   990 |<br>|  2 | b    |  1010 |<br>+—-+——+——-+<br>2 rows in set (0.05 sec)</p><p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.00 sec)</p><p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+—-+——+——-+<br>2 rows in set (0.04 sec)</p><p>事务给我们提供一个反悔的机会</p><h2 id="begin-或者start-transaction"><a href="#begin-或者start-transaction" class="headerlink" title="begin;或者start transaction"></a><strong>begin;</strong>或者<strong>start transaction</strong></h2><p>;都可以帮我们手动开启一个事务</p><p>mysql&gt; update user set money = money - 10 where name = ‘a’;                                                                                               update user set money = money + 10 where name = ‘b’;<br>Query OK, 1 row affected (0.02 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>Query OK, 1 row affected (0.01 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |   990 |<br>|  2 | b    |  1010 |<br>+—-+——+——-+<br>2 rows in set (0.04 sec)</p><p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.00 sec)</p><p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |   990 |<br>|  2 | b    |  1010 |<br>+—-+——+——-+<br>2 rows in set (0.04 sec)</p><p><strong>begin;</strong> 手动开启事务（start transaction）                                                                                                                                                                            </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> money = money - <span class="number">10</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'a'</span>;                                                                                               </span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> money = money + <span class="number">10</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'b'</span>;</span><br></pre></td></tr></table></figure><p>mysql&gt; begin;                                                                                                                                                                                      update user set money = money - 10 where name = ‘a’;                                                                                               update user set money = money + 10 where name = ‘b’;<br>Query OK, 0 rows affected (0.00 sec)</p><p>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |   980 |<br>|  2 | b    |  1020 |<br>+—-+——+——-+<br>2 rows in set (0.04 sec)</p><p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.01 sec)</p><p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |   990 |<br>|  2 | b    |  1010 |<br>+—-+——+——-+<br>2 rows in set (0.04 sec)</p><p>注意事务开启之后，一旦commit（提交），就不可以回滚（事务在提交的时候就结束了）</p><h2 id="事物的特征："><a href="#事物的特征：" class="headerlink" title="事物的特征："></a>事物的特征：</h2><p>事物的四大特征：</p><p>1.原子性（A）：事务是最小的单位，不可再分割</p><p>2.一致性（C）：事务要求，同一事务的sql语句，必须保证同时成功或者同时失败</p><p>3.隔离性（I）：事务1和事务2之间是具有隔离性的</p><p>4.持久性（D）：事务一旦结束（commit，rollback），就不可返回</p><p>事务开启：</p><p>1.修改默认提交：set sutocommit = 0;</p><p>2.begin;</p><p>3.start transaction;</p><p>事务手动提交：commit;</p><p>事务手动回滚：rollback;</p><h3 id="事物的隔离性"><a href="#事物的隔离性" class="headerlink" title="事物的隔离性:"></a>事物的隔离性:</h3><p>1.read uncommitted;   读未提交的</p><p>2.read committed;   读已提交的</p><p>3.repeatable read;   可以重复读</p><p>4.serializable;   串行化</p><h4 id="1-read-uncommitted"><a href="#1-read-uncommitted" class="headerlink" title="1.read uncommitted;"></a>1.read uncommitted;</h4><p>如果有事务a和事务b，a事务对数据进行操作，事务没有被提交，但是b可以看到a操作的结果</p><p>bank数据库 user表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'小明'</span>,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'淘宝店'</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>小明去淘宝店买东西，淘宝店查看钱是否到账？</p><p>如何查看数据库的隔离级别？</p><p>mysql8.0</p><p>系统级别：</p><p>select @@global.transaction_isolation;</p><p>会话级别：</p><p>select @@transaction_isolation;</p><p>mysql&gt; select @@global.transaction_isolation;</p><p>mysql默认隔离级别：</p><p>+——————————–+<br>| @@global.transaction_isolation |<br>+——————————–+<br>| REPEATABLE-READ                |<br>+——————————–+<br>1 row in set (0.04 sec)</p><p>mysql 5.x</p><p>select @@global.tx_isolation;</p><p>select @@tx_isolation;</p><p>如何修改隔离级别？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global transaction isolation level <span class="built_in">read</span> uncommitted;</span><br></pre></td></tr></table></figure><p>mysql&gt; set global transaction isolation level read uncommitted;<br>Query OK, 0 rows affected (0.02 sec)</p><p>mysql&gt; select @@global.transaction_isolation;<br>+——————————–+<br>| @@global.transaction_isolation |<br>+——————————–+<br>| READ-UNCOMMITTED               |<br>+——————————–+<br>1 row in set (0.04 sec)</p><p>好了开始转帐，小明买鞋子：800块钱</p><p>小明》》城都 ATM</p><p>淘宝店》》广州 ATM</p><p>mysql&gt; select * from user;<br>+—-+——–+——-+<br>| id | name   | money |<br>+—-+——–+——-+<br>|  1 | a      |   980 |<br>|  2 | b      |  1020 |<br>|  3 | 小明   |  1000 |<br>|  4 | 淘宝店 |  1000 |<br>+—-+——–+——-+<br>4 rows in set (0.05 sec)</p><p>start transaction;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> money = money<span class="number">-800</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'小明'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> money = money+<span class="number">800</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'淘宝店'</span>;</span><br></pre></td></tr></table></figure><p>mysql&gt; start transaction;</p><p>update user set money = money-800 where name = ‘小明’;</p><p>update user set money = money+800 where name = ‘淘宝店’;<br>Query OK, 0 rows affected (0.00 sec)</p><p>Query OK, 1 row affected (0.01 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>mysql&gt; select * from user;<br>+—-+——–+——-+<br>| id | name   | money |<br>+—-+——–+——-+<br>|  1 | a      |   980 |<br>|  2 | b      |  1020 |<br>|  3 | 小明   |   200 |<br>|  4 | 淘宝店 |  1800 |<br>+—-+——–+——-+<br>4 rows in set (0.04 sec)</p><p>给淘宝店打电话，说你去查一下，是不是到账了</p><p>淘宝店在广州查账</p><p>发货</p><p>淘宝店晚上请女朋友吃好吃的</p><p>1800</p><p>小明rollback</p><p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.01 sec)</p><p>mysql&gt; select * from user;<br>+—-+——–+——-+<br>| id | name   | money |<br>+—-+——–+——-+<br>|  1 | a      |   980 |<br>|  2 | b      |  1020 |<br>|  3 | 小明   |  1000 |<br>|  4 | 淘宝店 |  1000 |<br>+—-+——–+——-+<br>4 rows in set (0.04 sec)</p><p>结账的时候发现钱不够</p><p>如果两个不同的地方，都在进行操作，如果事务a开启之后，他的数据可以被其他事务读取到</p><p>这样就会出现脏读</p><p>脏读：一个事务读取到另外一个事物没有提交的数据就叫做脏读</p><p>实际开发不允许脏读出现</p><h4 id="2-read-committed"><a href="#2-read-committed" class="headerlink" title="2.read committed;"></a>2.read committed;</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global transaction isolation level <span class="built_in">read</span> committed;</span><br><span class="line"></span><br><span class="line">select @@global.transaction_isolation;</span><br></pre></td></tr></table></figure><p>mysql&gt; set global transaction isolation level read committed;</p><p>select @@global.transaction_isolation;<br>Query OK, 0 rows affected (0.00 sec)</p><p>+——————————–+<br>| @@global.transaction_isolation |<br>+——————————–+<br>| READ-COMMITTED                 |<br>+——————————–+<br>1 row in set (0.03 sec)</p><p>bank数据库 user表</p><p>小张：银行的会计</p><p>start transaction;</p><p>select * from user;</p><p>mysql&gt; select * from user;<br>+—-+——–+——-+<br>| id | name   | money |<br>+—-+——–+——-+<br>|  1 | a      |   980 |<br>|  2 | b      |  1020 |<br>|  3 | 小明   |  1000 |<br>|  4 | 淘宝店 |  1000 |<br>+—-+——–+——-+<br>4 rows in set (0.04 sec)</p><p>小张上厕所去了。。。顺便抽烟</p><p>小王：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'c'</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>commit;</p><p>mysql&gt; start transaction;</p><p>insert into user values(5,’c’,100);</p><p>commit;<br>Query OK, 0 rows affected (0.00 sec)</p><p>Query OK, 1 row affected (0.01 sec)<br>Query OK, 0 rows affected (0.01 sec)</p><p>mysql&gt; select * from user;<br>+—-+——–+——-+<br>| id | name   | money |<br>+—-+——–+——-+<br>|  1 | a      |   980 |<br>|  2 | b      |  1020 |<br>|  3 | 小明   |  1000 |<br>|  4 | 淘宝店 |  1000 |<br>|  5 | c      |   100 |<br>+—-+——–+——-+<br>5 rows in set (0.04 sec)</p><p>小张上完厕所抽完烟回来了，小王没有commit的时候，小张执行select * from user；</p><p>mysql&gt; select * from user;<br>+—-+———–+——-+<br>| id | name      | money |<br>+—-+———–+——-+<br>|  1 | a         |   980 |<br>|  2 | b         |  1020 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>+—-+———–+——-+<br>5 rows in set (0.00 sec)</p><p>但是执行select avg(money) from user;</p><p>mysql&gt; select avg(money) from user;<br>+————+<br>| avg(money) |<br>+————+<br>| 820.0000   |<br>+————+<br>1 row in set (0.07 sec)</p><p>money的平均值不是1000，变少了</p><p>虽然我只能读到另一个事务提交的数据，但是还是会出现问题，就是读取同一个表的数据，发现前后不一致，这种不可重复读现象，read committed</p><h4 id="3-repeatable-read-可以重复读"><a href="#3-repeatable-read-可以重复读" class="headerlink" title="3.repeatable read;   可以重复读"></a>3.repeatable read;   可以重复读</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global transaction isolation level repeatable <span class="built_in">read</span>;</span><br><span class="line"></span><br><span class="line">select @@global.transaction_isolation;</span><br></pre></td></tr></table></figure><p>mysql&gt; set global transaction isolation level repeatable read;</p><p>select @@global.transaction_isolation;</p><p>Query OK, 0 rows affected (0.00 sec)</p><p>+——————————–+<br>| @@global.transaction_isolation |<br>+——————————–+<br>| REPEATABLE-READ                |<br>+——————————–+<br>1 row in set (0.03 sec)</p><p>张全蛋</p><p>start transaction;</p><p>insert into user values(6,’d’,1000);</p><p>张全蛋可以查到6号信息</p><p>王尼玛：</p><p>start transaction;</p><p>王尼玛查不到6号信息</p><p>但是王尼玛不能插入6号，会报错</p><p>这种现象叫做幻读</p><p>事务a和事务b同时操作一张表，事务a提交的数据，也不能读到，就可能造成幻读</p><h4 id="serializable-串行化"><a href="#serializable-串行化" class="headerlink" title="serializable:串行化"></a>serializable:串行化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global transaction isolation level serializable;</span><br><span class="line"></span><br><span class="line">select @@global.transaction_isolation;</span><br></pre></td></tr></table></figure><p>还是张全蛋和王尼玛，做了和上面一样的事</p><p>当user表被另外一个事务操作的时候，其他的事务是不可以执行的，进入排队状态，直到操作事务的那个人commit之后，才会执行</p><p>串行化commit之后，其他事务立刻执行，但时间长了，可能会失效</p><p>串行化问题：性能特差</p><p>read uncommitted &gt;read commited&gt;repeatable read&gt;serializable</p><p>隔离级别越高，性能越差</p><p>mysql默认隔离级别事 peteatable read</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_mysql_next</title>
      <link href="/2019/08/16/java/mysql/next/"/>
      <url>/2019/08/16/java/mysql/next/</url>
      
        <content type="html"><![CDATA[<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a><center>子查询</center></h4><a id="more"></a><h2 id="select特殊功能："><a href="#select特殊功能：" class="headerlink" title="select特殊功能："></a>select特殊功能：</h2><p><strong>distinct(排重)</strong>：select distinct 字段名 from 数据表;</p><p><strong>between…and</strong>：select * from 数据表 where 字段名 between 值 and 值; 相当于select * from 数据表 where 字段名&gt;字段值 and 字段名&lt;字段值;</p><p><strong>in</strong>：select * from 数据表 where 字段名 in(85，86，87);</p><p><strong>or</strong>：select * from 数据表 where 字段名1 = ‘值’ or 字段名2 = ‘值’;(升序查询 asc从小到大)select * from 数据表 order by 字段名 asc; order by：系统默认是升序 desc降序（从大到小）</p><p><strong>count(统计)</strong>：select count(*) from 数据表 where 字段名 = 值; (聚合函数)</p><p><strong>avg(平均)</strong>：select avg(字段名) from 数据表 where 字段名 = 值;(聚合函数)</p><p><strong>as</strong>：起别名</p><p><strong>like(%)</strong>：模糊查询    %代表任意字段</p><p><strong>not like</strong>：模糊查询相反</p><p><strong>order by</strong>(降序查询  desc从大到小)：select * from 数据表 order by 字段名 desc;</p><p><strong>group by</strong>：需要和  <u><em>聚合函数</em></u>（例如：max（），count（），avg（）等）配合使用，使用时至少有一个分组标识字段（例如某一列的列名），分组标识的字段如果有多个相同的，那么搜索结果中只会出现第一次查到的这个字段的记录的信息，可以通过having</p><p><strong>having</strong>(分组条件)：作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。</p><p>可以包含<u><em>聚集函数</em></u>，但是where不能包含<u><em>聚集函数</em></u></p><p><strong>year(sbirthday)</strong>：查询出生年份   year(now())：查看当前年份</p><p><strong>union</strong>：把两个查询的结果连接起来</p><p><strong>any</strong>：字段中 任意的某条记录</p><p><strong>all</strong>：字段中 所有的记录</p><p><strong>count(*)</strong>：函数返回由select语句返回的结果集中的行数</p><p><strong>max(字段名)</strong>：字段中的最大值</p><p><strong>min(字段名)</strong>：字段中的最小值</p><p><strong>查询字段中的最大最小</strong>：</p><p>一：（子查询）</p><p>select * from 数据表 where 字段名 = (select max(字段名) from 数据表);</p><p>1.找到最高分：select max(字段名) from 数据表;</p><p>2.根据最高分查询考生信息：select * from 数据表 where 字段名 = (select max(字段名) from 数据表);</p><p>二：（排序）</p><p>select * from 数据表 order by 字段名 desc limit 0,1;</p><p>limit：第一个数字是从多少条开始，第二个数字是查多少条</p><p>这个是降序，限制获得第一条，第一条就是最大的，获得最大值</p><p>注意：排序有缺陷，如果最大值有两条，她只能查到一条</p><p><strong>查询score表中至少有两名学生选修的并以3开头的课程的平均分数</strong></p><p><strong>having</strong>(分组条件)：having字句可以让我们筛选成组后的各种数据，where字句在聚合前先筛选记录，也就是说作用在group by和having字句前。而 having子句在聚合后对组记录进行筛选。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cno <span class="keyword">from</span> score <span class="keyword">group</span> <span class="keyword">by</span> cno <span class="keyword">having</span> <span class="keyword">count</span>(cno)&gt;=<span class="number">2</span> <span class="keyword">and</span> cno <span class="keyword">like</span> <span class="string">'3%'</span>;</span><br></pre></td></tr></table></figure><p>  %代表的是任意的东西   3%代表以3开头的任意东西</p><h2 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h2><p><strong>精髓</strong>：他们是根据相等的地方进行联系的</p><p>两张表：</p><p>查询当条件相同时，把数据替换掉</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sname,cno,degree <span class="keyword">from</span> student,score <span class="keyword">where</span> student.sno = score.sno;</span><br></pre></td></tr></table></figure><p>三张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sname,cname,degree <span class="keyword">from</span> student,course,score <span class="keyword">where</span> student.sno = score.sno                                                                 </span><br><span class="line"><span class="keyword">and</span> course.cno = score.cno;</span><br></pre></td></tr></table></figure><h2 id="子查询："><a href="#子查询：" class="headerlink" title="子查询："></a>子查询：</h2><p><strong>精髓</strong>：分开步骤去查</p><p>查一个班的学生：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">class</span> = <span class="string">'95031'</span>;</span><br></pre></td></tr></table></figure><p>查学生的分数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> <span class="keyword">class</span> = <span class="string">'95031'</span>;</span><br></pre></td></tr></table></figure><p>查一个班学生的平均成绩：                                                                     </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cno,<span class="keyword">avg</span>(degree)  <span class="keyword">from</span> score  <span class="keyword">where</span> sno <span class="keyword">in</span> (<span class="keyword">select</span> sno <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">class</span> = <span class="string">'95031'</span>) <span class="keyword">group</span> <span class="keyword">by</span> cno;</span><br></pre></td></tr></table></figure><p>查询选修3-105课程成绩高于109号同学3-105成绩的所有同学的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> cno=<span class="string">'3-105'</span> <span class="keyword">and</span> degree&gt;(<span class="keyword">select</span> degree <span class="keyword">from</span> score <span class="keyword">where</span> sno=<span class="string">'109'</span> <span class="keyword">and</span> cno=<span class="string">'3-105'</span>);</span><br></pre></td></tr></table></figure><p>查询成绩高于学号为109、课程号为3-105的成绩的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span>* score <span class="keyword">where</span> degree&gt;(<span class="keyword">select</span> degree <span class="keyword">from</span> score <span class="keyword">where</span> sno=<span class="string">'109'</span> <span class="keyword">and</span> cno=<span class="string">'3-105'</span>);</span><br></pre></td></tr></table></figure><p>查询与学号为108和101的同学同年出生的所有学生</p><p>查询学号为108和101的学生：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> sno <span class="keyword">in</span>(<span class="number">108</span>,<span class="number">101</span>);</span><br></pre></td></tr></table></figure><p>查询学号为108和101学生的出生年份：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &lt;u&gt;*<span class="keyword">year</span>(sbirthday)*&lt;/u&gt; <span class="keyword">from</span> student <span class="keyword">where</span> sno <span class="keyword">in</span>(<span class="number">108</span>,<span class="number">101</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">year</span>(sbirthday) <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">year</span>(sbirthday) <span class="keyword">from</span> student <span class="keyword">where</span> sno <span class="keyword">in</span>(<span class="number">108</span>,<span class="number">101</span>));</span><br></pre></td></tr></table></figure><p>查询张旭教师任课的学生成绩：</p><p>教师表中查询tno：select tno from teacher where tname=’张旭’;</p><p>查询他任的课cno：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cno <span class="keyword">from</span> cource <span class="keyword">where</span> tno=(<span class="keyword">select</span> tno <span class="keyword">from</span> teacher <span class="keyword">where</span> tname=<span class="string">'张旭'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> cno <span class="keyword">in</span>(<span class="keyword">select</span> cno <span class="keyword">from</span> cource <span class="keyword">where</span> tno=(<span class="keyword">select</span> tno <span class="keyword">from</span> teacher <span class="keyword">where</span> tname=<span class="string">'张旭'</span>));</span><br></pre></td></tr></table></figure><p>查询某课程的同学数多余5人的教师姓名：</p><p>课程数大于五的cno：select cno from score group by cno having count(*)&gt;5;</p><p>查询tno：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> tno <span class="keyword">from</span> course <span class="keyword">where</span> cno <span class="keyword">in</span>(<span class="keyword">select</span> cno <span class="keyword">from</span> score <span class="keyword">group</span> <span class="keyword">by</span> cno <span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;<span class="number">5</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> tname <span class="keyword">from</span> teacher <span class="keyword">where</span> tno <span class="keyword">in</span>(<span class="keyword">select</span> tno <span class="keyword">from</span> course <span class="keyword">where</span> cno=(<span class="keyword">select</span> cno <span class="keyword">from</span> score <span class="keyword">group</span> <span class="keyword">by</span> cno <span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>查看计算机系和电子工程系不同职称的教师的tname和pref</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prof <span class="keyword">from</span> teacher <span class="keyword">where</span> depart = <span class="string">'电子工程系'</span> <span class="keyword">and</span> prof <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> * <span class="keyword">from</span> teacher <span class="keyword">where</span> depart = <span class="string">'计算机系'</span>)</span><br></pre></td></tr></table></figure><p><u><strong><em>union</em></strong></u></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> teacher <span class="keyword">where</span> depart = <span class="string">'计算机系'</span> <span class="keyword">and</span> prof <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> prof <span class="keyword">from</span> teacher <span class="keyword">where</span> depart = <span class="string">'电子工程系'</span> );</span><br></pre></td></tr></table></figure><p>查询选修学号为3-105课程且成绩至少高于选修编号3-245的同学的Cno、Sno和Degree，并按Degree从高到底依次排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cno,sno,degree <span class="keyword">from</span> score                                         </span><br><span class="line"><span class="keyword">where</span> cno=<span class="string">'3-105'</span></span><br><span class="line"><span class="keyword">and</span> degree&gt;&lt;u&gt;**<span class="keyword">any</span>**&lt;/u&gt;(<span class="keyword">select</span> degree <span class="keyword">from</span> score <span class="keyword">where</span> cno=<span class="string">'3-245'</span>)   </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> degree <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>   //从高到低</p><p>复制表数据做条件查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score a <span class="keyword">where</span> degree&lt;(<span class="keyword">select</span> <span class="keyword">avg</span>(degree) <span class="keyword">from</span> score b <span class="keyword">where</span> a.cno=b.cno);</span><br></pre></td></tr></table></figure><p>查询至少有两名男生的班级：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">class</span> <span class="keyword">from</span> student <span class="keyword">where</span> ssex = <span class="string">'男'</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">class</span> <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>按等级查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sno,cno,grade <span class="keyword">from</span> score,grade <span class="keyword">where</span> degree <span class="keyword">between</span> <span class="keyword">low</span> <span class="keyword">and</span> upp;</span><br></pre></td></tr></table></figure><h2 id="sql的四种链接查询："><a href="#sql的四种链接查询：" class="headerlink" title="sql的四种链接查询："></a>sql的四种链接查询：</h2><p><strong>内链接：</strong></p><p>inner join 或者 join</p><p><strong>外连接：</strong></p><p>1.左连接：left join 或者 left outer join</p><p>2.右连接：right join 或者 right outer join</p><p>3.完全外连接：full join 或者 full outer join</p><p>person表：id，name，cardId</p><p>card表：id，name</p><p>person表中的cardId来自于card表中的id</p><p>create table person(</p><p>​    id int,</p><p>​    name varchar(20),</p><p>​    cardId int</p><p>);</p><p>create table card(</p><p>​    id int,</p><p>​    name varchar(20)</p><p>);</p><p>insert into card values(1,’饭卡’);</p><p>insert into card values(2,’建行卡’);</p><p>insert into card values(3,’农行卡’);</p><p>insert into card values(4,’工商卡’);</p><p>insert into card values(5,’邮政卡’);</p><p>insert into person values(1,’张三’,1);</p><p>insert into person values(2,’李四’,3);</p><p>insert into person values(3,’王五’,6);</p><p>并没有创建外键，如果创建的话person里面的第三条数据插不进去</p><p><strong>inner join查询</strong>：(内连接)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person p <span class="keyword">inner</span> <span class="keyword">join</span> card c <span class="keyword">on</span> p.cardId = c.id;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person p, card c <span class="keyword">where</span> c.id = p.cardId;</span><br></pre></td></tr></table></figure><p>内联查询：其实就是相当于把两个表里面的数据，通过某个字段相对应，把有关系的数据查询出来</p><p>mysql&gt; select * from person p, card c where c.id = p.cardId;<br>+—-+——+——–+—-+——–+<br>| id | name | cardId | id | name   |<br>+—-+——+——–+—-+——–+<br>|  1 | 张三 |      1 |  1 | 饭卡   |<br>|  2 | 李四 |      3 |  3 | 农行卡 |<br>+—-+——+——–+—-+——–+</p><p><strong>left join:</strong>（左外连接)outer</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person <span class="keyword">left</span> <span class="keyword">join</span> card <span class="keyword">on</span> person.cardId = card.id;</span><br></pre></td></tr></table></figure><p>左外连接：会把左边表里的数据全部取出来，而右边表里的数据有就显示出来，没有就会变成NULL</p><p>mysql&gt; select * from person left join card on person.cardId = card.id;<br>+—-+——+——–+——+——–+<br>| id | name | cardId | id   | name   |<br>+—-+——+——–+——+——–+<br>|  1 | 张三 |      1 |    1 | 饭卡   |<br>|  2 | 李四 |      3 |    3 | 农行卡 |<br>|  3 | 王五 |      6 | NULL | NULL   |<br>+—-+——+——–+——+——–+</p><p><strong>right join：</strong>(右外连接)outer</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person <span class="keyword">right</span> <span class="keyword">join</span> card <span class="keyword">on</span> person.cardId = card.id;</span><br></pre></td></tr></table></figure><p>左外连接：会把右边表里的数据全部取出来，而左边表里的数据有就显示出来，没有就会变成NULL</p><p>mysql&gt; select * from person right join card on person.cardId = card.id;<br>+——+——+——–+—-+——–+<br>| id   | name | cardId | id | name   |<br>+——+——+——–+—-+——–+<br>|    1 | 张三 |      1 |  1 | 饭卡   |<br>|    2 | 李四 |      3 |  3 | 农行卡 |<br>| NULL | NULL | NULL   |  2 | 建行卡 |<br>| NULL | NULL | NULL   |  4 | 工商卡 |<br>| NULL | NULL | NULL   |  5 | 邮政卡 |<br>+——+——+——–+—-+——–+</p><p><strong>full join：</strong>（全外连接）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person <span class="keyword">full</span> <span class="keyword">join</span> card <span class="keyword">on</span> person.cardId = card.id;</span><br></pre></td></tr></table></figure><p>mysql&gt; select * from person full join card on person.cardId = card.id;<br>1054 - Unknown column ‘person.cardId’ in ‘on clause’</p><p>原因是mysql不支持full join</p><p><u><em>全外连接我们想要的结果：</em></u></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person <span class="keyword">left</span> <span class="keyword">join</span> card <span class="keyword">on</span> person.cardId = card.id          </span><br><span class="line"><span class="keyword">union</span>    </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person <span class="keyword">right</span> <span class="keyword">join</span> card <span class="keyword">on</span> person.cardId = card.id;</span><br></pre></td></tr></table></figure><p>+——+——+——–+——+——–+<br>| id   | name | cardId | id   | name   |<br>+——+——+——–+——+——–+<br>|    1 | 张三 |      1 |    1 | 饭卡   |<br>|    2 | 李四 |      3 |    3 | 农行卡 |<br>|    3 | 王五 |      6 | NULL | NULL   |<br>| NULL | NULL | NULL   |    2 | 建行卡 |<br>| NULL | NULL | NULL   |    4 | 工商卡 |<br>| NULL | NULL | NULL   |    5 | 邮政卡 |<br>+——+——+——–+——+——–+                                                                   </p><p>连接的好处：<strong>可以不创建外键</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_mybatis_start</title>
      <link href="/2019/08/14/java/mybatis/start/"/>
      <url>/2019/08/14/java/mybatis/start/</url>
      
        <content type="html"><![CDATA[<h4 id="mybatis使用不同方法进行增删改查"><a href="#mybatis使用不同方法进行增删改查" class="headerlink" title="mybatis使用不同方法进行增删改查"></a><center>mybatis使用不同方法进行增删改查</center></h4><a id="more"></a><h2 id="对原生态jdbc程序问题的总结"><a href="#对原生态jdbc程序问题的总结" class="headerlink" title="对原生态jdbc程序问题的总结"></a>对原生态jdbc程序问题的总结</h2><p>（单独使用jdbc开发）</p><p>数据库用的时候连接，不用的时候释放，频繁操作   通过连接池节约资源</p><p>sql语句硬编码，不利于系统维护   使用配置文件把他配起来</p><h2 id="mybatis框架原理"><a href="#mybatis框架原理" class="headerlink" title="mybatis框架原理"></a>mybatis框架原理</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>mybatis是持久层框架，是apache下的项目</p><p>mybatis让程序主要精力放在sql上，通过mybatis提供的映射方式，简化sql</p><p>mybatis将输入参数自动进行输入映射，将查询结果集映射成java对象</p><h3 id="mybatis框架"><a href="#mybatis框架" class="headerlink" title="mybatis框架"></a>mybatis框架</h3><p>先完成基本配置：</p><p>SqlMapConfig.xml：是mybatis的全局配置文件（名称不固定）。配置了数据源（c3p0）、事务（spring）等mybatis运行环境。配置里有个特别的东西（mapper.xml）这个文件里是映射关系（配置sql语句）通过配置文件生成会话工厂（SqlSessionFactory）</p><p>操作数据库：</p><p>SqlSessionFactory（会话工厂）创建 -&gt;SqlSession（接口）：会话 作用：操作数据库（发出sql增删改查）内部通过执行器（Excutor接口）操作数据库,两种实现方式（基本执行器、缓存执行器）。</p><p>这个执行器需要很多参数，所以mybatis提供了一个<em>底层的封装对象（mapped statement）</em>作用：对数据库存储封装，包括sql语句，输入参数，输出结果类型，终于连接上了数据库</p><p>输入参数类型：pojo、java简单类型、hashmap</p><p>输出结果类型：pojo、java简单类型、hashmap</p><h2 id="mybatis入门程序"><a href="#mybatis入门程序" class="headerlink" title="mybatis入门程序"></a>mybatis入门程序</h2><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><p><em>lib下的一般是依赖包</em></p><h4 id="查询用户信息"><a href="#查询用户信息" class="headerlink" title="查询用户信息"></a>查询用户信息</h4><p>根据用户名称模糊查询用户信息</p><p><u>首先在映射文件中配置sql语句</u>   映射：（hibernate：orm：对象关系映射，实体类和数据表映射）咱们的xml映射分为输入映射、输出映射</p><p>映射文件名 :user.xml(ibatis)、xxxMapper.xml(mybatis)</p><p>namespace命名空间，sql的隔离</p><p>映射文件中的sql语句会封装到<em>mapped statement</em>对象中</p><p>在SqlMapConfig.xml中加载刚刚写好的xxxMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"路径/xxxMapper.xml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>程序编写，创建会话工厂，连接数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mybatis配置文件</span></span><br><span class="line"></span><br><span class="line">String resource = <span class="string">"sqlmap/SqlMapConfig.xml"</span>;</span><br><span class="line"></span><br><span class="line">得到配置文件的流</span><br><span class="line"></span><br><span class="line">Resource.getResourceAsStream(resource);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建会话工厂传入mybatis的配置文件信息，需要一个配置文件流</span></span><br><span class="line"></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过工厂得到会话SqlSession</span></span><br><span class="line"></span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过SqlSession操作数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数：映射文件中的statement的id，等于=namespace+"."+statement的id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个参数：指定和映射文件中所匹配的parameterType类型的参数</span></span><br><span class="line"></span><br><span class="line">User user = sqlSession.selectOne(statement,parameter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line"></span><br><span class="line">sqlSession.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure><h5 id="sql语句的格式"><a href="#sql语句的格式" class="headerlink" title="sql语句的格式"></a>sql语句的格式</h5><p>id：标识映射文件中的sql</p><p>将sql语句封装到mapped statement 对象中，所以id称为statement的id</p><p>parameterType：指定输入参数的类型</p><p>#{}表示一个占位符号</p><p>${}表示一个拼接符号，会引起sql注入（拼接的时候写where 1=1）</p><p>#{id}：其中的id表示接入输入的参数，参数名称就是id，如果输入参数是简单类型，#{}中的参数名可以任意，可以实value或其他的名称都行</p><p>resultType：指定输出结果的类型，表示将单条记录映射成java对象</p><p>selectOne表示查询出1条记录进行映射</p><p>selectList表示查询出一个列表（多条记录）进行映射</p><h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><p>parameterType：指定输入参数类型是pojo（包括用户信息）</p><p>#{}中指定的pojo的属性名，接收到pojo对象的属性值OGNL获取对象的属性值</p><p>sql后面不要加;</p><p><strong>自增主键返回</strong>：执行insert提交之前自动生成一个自增主键。通过mysql函数获取到刚插入记录的自增主键（select last_insert_idid();）在inseert之后调用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span> = <span class="string">"insertUser"</span> <span class="attr">parameterType</span> = <span class="string">"cn.itcast.mybatis.po.User"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">order：select last_insert_id()执行顺序，相对于insert语句来说他的执行顺序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">resultType:指定select last_insert_id()结果的类型--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"after"</span> <span class="attr">resultType</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    select last_insert_id();</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line"></span><br><span class="line">insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;adress&#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>非自增主键的返回</strong>：</p><p>mysql的uuid()函数生成主键，需要修改id字段类型的为String，长度设置为35位</p><p>执行思路：先通过uuid();查询到主键，将主键注入到sql语句中，执行uuid();语句顺序相对于insert语句之前执行</p><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>sqlSession.update(statement,parameter);</p><p>sqlSession.delete(statement,parameter);</p><p>sqlSession.selectOne/List(statement,parameter);</p><p>sqlSession.insert(statement,parameter);</p><h4 id="更新用户"><a href="#更新用户" class="headerlink" title="更新用户"></a>更新用户</h4><h3 id="入门程序的总结"><a href="#入门程序的总结" class="headerlink" title="入门程序的总结"></a>入门程序的总结</h3><p>#{}表示一个占位符，接受输入参数，类型可以是简单类型、pojo、hashmap，如果接受简单类型，#{}中可以写成value或其他名称</p><p>#{}接受pojo对象值，通过OGNL读取对象的属性值，通过属性.属性.属性…的方式获取属性值</p><p>${}表示一个拼接符，会出现sql注入，不建议使用。接受输入参数，类型可以是简单类型、pojo、hashmap，如果接受简单类型，#{}中只能写成value</p><p>${}接受pojo对象值，通过OGNL读取对象的属性值，通过属性.属性.属性…的方式获取属性值</p><h4 id="mybatis和hibernate本质区别和应用场景"><a href="#mybatis和hibernate本质区别和应用场景" class="headerlink" title="mybatis和hibernate本质区别和应用场景"></a>mybatis和hibernate本质区别和应用场景</h4><p><strong>hibernate</strong>：入门门槛较高，是一个标准的ORM框架（对象关系映射），不需要程序员写sql，sql语句自动生成。对sql语句的优化、修改比较困难</p><p><strong>应用场景</strong>：适应于需求变化较少的中小型的项目，比如：后台管理系统，erp、orm、oa…</p><p><strong>mybatis</strong>：专注于sql本身，需要程序员自己编写sql语句，sql修改、优化比较方便。mybatis是一个不完全的ORM框架，虽然程序员自己写sql，但是存在映射（输入映射、输出映射）</p><p><strong>应用场景</strong>：适应于需求项目较多的项目，比如：互联网项目</p><p>企业进行技术选型，以低成本、高回报作为技术选型的原则，根据项目组的项目力量进行选择</p><h2 id="mybatis开发dao的两种方法"><a href="#mybatis开发dao的两种方法" class="headerlink" title="mybatis开发dao的两种方法"></a>mybatis开发dao的两种方法</h2><h3 id="SqlSession使用范围（单例）"><a href="#SqlSession使用范围（单例）" class="headerlink" title="SqlSession使用范围（单例）"></a>SqlSession使用范围（单例）</h3><p>通过<strong>SqlSessionFactoryBuilder</strong>创建SqlSessionFactory，将SqlSessionFactoryBuilder当成一个工具类即可，不需要使用单例管理SqlSessionFactoryBuilder。在需要创建工厂的时候只需要创建一次SqlSessionFactoryBuilder即可（因为下面的SqlSessionFactory是单例管理的）</p><p>通过<strong>SqlSessionFactory</strong>创建SqlSession，通过使用单例模式管理sqlSessionFactory（工厂一旦创建，就一直使用一个实例）</p><p>将来mybatis和spring整合后，使用单例模式管理sqlSessionFactory</p><p>SqlSession：是一个面向用户（程序员）的接口提供了很多操作数据库的方法：如：selectOne、selectList。是线程不安全的，在SqlSession的实现类中，除了有接口中的方法（操作数据库的方法）、还有数据域的属性（多例不安全）。<em>SqlSession最佳的应用场合在方法体内，定义成局部变量</em></p><h3 id="原始dao开发方法"><a href="#原始dao开发方法" class="headerlink" title="原始dao开发方法"></a>原始dao开发方法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>需要编写dao接口和dao实现类</strong></p><p>需要向dao实现类中注入SqlSessionFactory，在方法体中通过SqlSessionFactory常见SqlSession</p><h4 id="dao接口"><a href="#dao接口" class="headerlink" title="dao接口"></a>dao接口</h4><h4 id="dao接口实现类"><a href="#dao接口实现类" class="headerlink" title="dao接口实现类"></a>dao接口实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要向dao实现类中注入SqlSessionFactory</span></span><br><span class="line"></span><br><span class="line">这里通过构造方法注入</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> 类名 (SqlSessionFactory sqlSessionFactory)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/1565315234136.png" alt></p><p>@Befor是在测试类之前执行的类：需要创建会话工厂，供测试类通过构造器注入</p><p>@Text是测试类：创建UserDao这个实现类的时候，UserDaoImpl构造器需要一个sqlSessionFactory，有@Befor提供；创建成功后可以开始调用UserDao里面的方法</p><h4 id="总结原始dao开发的问题"><a href="#总结原始dao开发的问题" class="headerlink" title="总结原始dao开发的问题"></a>总结原始dao开发的问题</h4><p>1.dao接口的实现类的方法中存在大量的模板方法，设想能否将这些代码提取出来，大大减轻程序员的工作量</p><p>2.第一个参数：看这个蓝色的地方：是个硬编码（statement的id硬编码）</p><p>3.第二个参数的类型是泛型，即使传入参数错误，在编译阶段也不报错，不利于程序员开发</p><p><img src="/images/1565316318487.png" alt></p><h3 id="mybatis的mapper代理的开发方法"><a href="#mybatis的mapper代理的开发方法" class="headerlink" title="mybatis的mapper代理的开发方法"></a>mybatis的mapper代理的开发方法</h3><p>程序员编写mapper.xml映射文件</p><p>程序员编写mapper接口（相当于dao接口）需要遵循一些开发规范，mybatis可以自动生成mapper接口实现类代理对象。</p><p>mybatis可以自动生成mapper接口实现类的代理对象</p><h4 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h4><p>1.在mapper.xml中namespace等于mapper接口的地址</p><p>2.mapper.java接口中的方法名，和mapper.xml中的statement的id一致</p><p>3.mapper.java接口中的方法输入参数类型和mapper.xml中statement中的statement的parameterType指定的类型一致</p><p>4.mapper.java中的返回值类型和mapper.xml中的statement中的resultType指定的类型一致</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上的开发规范主要是对下边的代码进行统一的生成</p><p>namespace变成了mapper.java的路径，mapper.java中的方法名是mapper.xml的staement的id，mybatis会自动拼接这两个东西生成原始Dao开发的第一个参数，第二个参数由第三条和第四条规范实现了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">User user = sqlSession.selectOne(<span class="string">"namespace+statement的id"</span>,占位符对应的输入参数);</span><br><span class="line"></span><br><span class="line">sqlSession.insert(<span class="string">""</span>,);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启会话，无论是什么开发，都得开启会话</span></span><br><span class="line"></span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建UserMapper对象,mybatis自动生成mapper代理对象</span></span><br><span class="line"></span><br><span class="line">UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">调用userMapper的方法</span><br></pre></td></tr></table></figure><p>注意：要在SqlMapConfig.xml中加载mapper.xml</p><h4 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h4><h5 id="代理对象内部调用selectOne或selectList"><a href="#代理对象内部调用selectOne或selectList" class="headerlink" title="代理对象内部调用selectOne或selectList"></a>代理对象内部调用selectOne或selectList</h5><p>如果mapper方法返回单个pojo对象（非集合对象），代理对象的内部通过selectOne查询数据库</p><p>如果mapper方法返回对象集合，代理对象内部通过selectList查询数据库</p><h5 id="mapper接口方法的参数个数"><a href="#mapper接口方法的参数个数" class="headerlink" title="mapper接口方法的参数个数"></a>mapper接口方法的参数个数</h5><p>mapper接口方法的参数个数只能有一个，系统是否不利于系统维护</p><p>系统框架中，dao层的代码是被业务层共用的，即使mapper接口只有一个参数，可以使用包装类型的pojo瞒住不同业务方法的参数</p><p>注意：持久层中方法的参数可以用包装类型、map等，但是service方法中建议不要使用包装类型（不利于业务层的可扩展性）</p><h2 id="Mapper代理开发和dao原始开发总结"><a href="#Mapper代理开发和dao原始开发总结" class="headerlink" title="***Mapper代理开发和dao原始开发总结"></a>***Mapper代理开发和dao原始开发总结</h2><h3 id="原始开发："><a href="#原始开发：" class="headerlink" title="原始开发："></a>原始开发：</h3><p>映射文件中的sql语句会封装到<em>mapped statement</em>对象中</p><p>在SqlMapConfig.xml中加载刚刚写好的xxxMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line">​<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"路径/xxxMapper.xml"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>程序编写，创建会话工厂，连接数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mybatis配置文件</span></span><br><span class="line"></span><br><span class="line">String resource = <span class="string">"sqlmap/SqlMapConfig.xml"</span>;</span><br><span class="line"></span><br><span class="line">得到配置文件的流</span><br><span class="line"></span><br><span class="line">Resource.getResourceAsStream(resource);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建会话工厂传入mybatis的配置文件信息，需要一个配置文件流</span></span><br><span class="line"></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过工厂得到会话SqlSession，这个不论是怎么开发都必须有的</span></span><br><span class="line"></span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过SqlSession操作数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数：映射文件中的statement的id，等于=namespace+"."+statement的id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个参数：指定和映射文件中所匹配的parameterType类型的参数这里有缺陷</span></span><br><span class="line"></span><br><span class="line">User user = sqlSession.selectOne(statement,parameter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line"></span><br><span class="line">sqlSession.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure><p>自己配置SqlMapConfig.xml 和 mapper.xml</p><p>通过配置文件生成会话工厂（SqlSessionFactory）</p><p>通过会话工厂生成会话（SqlSession） </p><p>通过SqlSession操作数据库</p><p><strong>开发的流程：</strong></p><p>编写写sql的xml，在mybatis全局配置的xml中加载编写sql的xml</p><p><em>编写sql的xml里的namespace对应mapper.java的类的全路径，里面的sql的id对应类中的方法名（原始开发的第一个参数statementid）。mapper.java里面的方法入参和出参对应原始dao开发的第二个参数</em></p><h3 id="mapper代理开发"><a href="#mapper代理开发" class="headerlink" title="mapper代理开发"></a>mapper代理开发</h3><h4 id="开发规范-1"><a href="#开发规范-1" class="headerlink" title="开发规范"></a>开发规范</h4><p>1.在mapper.xml中namespace等于mapper接口的地址</p><p>2.mapper.java接口中的方法名，和mapper.xml中的statement的id一致</p><p>3.mapper.java接口中的方法输入参数类型和mapper.xml中statement中的statement的parameterType指定的类型一致</p><p>4.mapper.java中的返回值类型和mapper.xml中的statement中的resultType指定的类型一致</p><p><strong>在原始开发中添加了开发规范，这些开发规范的作用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数：映射文件中的statement的id，等于=namespace+"."+statement的id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个参数：指定和映射文件中所匹配的parameterType类型的参数这里有缺陷，第二个参数是泛型</span></span><br><span class="line"></span><br><span class="line">User user = sqlSession.selectOne(statement,parameter);</span><br></pre></td></tr></table></figure><p>第一条和第二条开发规范优化了SqlSession的第一个参数，系统可以自动拼接，不需要我们去传入了</p><p>第三条和第四条开发规范优化了SqlSession的第二个参数，可以判断他的parameterType和resultType，而不是原始开发中的泛型</p><h2 id="mybatis的配置文件SqlMapConfig-xml"><a href="#mybatis的配置文件SqlMapConfig-xml" class="headerlink" title="mybatis的配置文件SqlMapConfig.xml"></a>mybatis的配置文件SqlMapConfig.xml</h2><p>mybatis的全局配置文件SqlMapConifig.xml，配置内容如下：</p><p>properties（属性)、setting（全局配置参数）、typeAliases（类型别名）、typeHandlers（类型处理器）、objectFactory（对象工厂）、plugins（插件）、environments（环境集合属性对象）（environment（环境子属性对象（transactionManager（事务管理）、dataSource（数据源））））、mappers（映射器）</p><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p><strong>需求：</strong></p><p>将数据库连接的参数单独配置在db.properties中，只需要在SqlMapConfig.xml中加载db.properties的属性值（添加了一个配置文件），这样做的话，在SqlMapConfig.xml中就不需要对数据库的连接参数进行硬编码。</p><p>将数据库连接参数只配置在db.properties中的原因：方便对参数的统一管理，其他的xml可以引用改db.properties</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SqlMapConfig.xml加载属性文件（db.properties）--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span> = <span class="string">"db.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置数据库连接池--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"driver"</span> <span class="attr">value</span> = <span class="string">"$&#123;文件中的属性名称&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>properties特性：</strong></p><p>mybatis将按照下面的顺序来加载属性：</p><p>1.在properties元素体内定义属性首先被读取</p><p>2.然后会读取properties元素中resource或url加载的属性，他会覆盖已读取的同名属性</p><p>3.最后读取parameterType传递的属性，他会覆盖已读取的同名属性</p><p>因此，通过parameterType传递的属性具有最高优先级，resource或url加载的属性次之，最低优先级是properties元素体内定义的属性</p><p>建议：不要再properties元素体内添加任何属性值，只将属性值定义在properties文件中，在properties文件中定义属性名要有一定的特殊性，如xxx.xxx</p><h3 id="settings全局参数配置"><a href="#settings全局参数配置" class="headerlink" title="settings全局参数配置"></a>settings全局参数配置</h3><p>mybatis运行时可以调整一些运行参数</p><p>比如：开启二级缓存，开启延迟加载</p><p><img src="/images/1565343104480.png" alt></p><p>这些参数会影响mybatis的运行行为，如果操作不当，可能会导致运行出现问题</p><h3 id="typeAliases（别名）"><a href="#typeAliases（别名）" class="headerlink" title="typeAliases（别名）"></a>typeAliases（别名）</h3><p><strong>需求：</strong></p><p>在mapper.xml中，定义很多的statement，statement需要parameterType指定输入参数类型、需要resultType指定输出结果的映射类型</p><p>如果在指定类型的时候输入类型全路径，不方便进行开发，可以针对parameterType或ResultType指定的类型定义一些别名，在mapper.xml中通过别名定义，方便开发</p><p>mybatis有一些自己默认的别名，但是对于pojo需要自己定义别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​//单个别名的定义</span><br><span class="line"></span><br><span class="line">​<span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span> = <span class="string">"全路径名（pojo类的路径）"</span> <span class="attr">alias</span> = <span class="string">"别名"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">​//批量别名的定义</span><br><span class="line"></span><br><span class="line">​指定包名，mybatis自动扫描包中的po类，别名就是类名（首字母大小写都可以）</span><br><span class="line"></span><br><span class="line">​<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span> = <span class="string">"包名"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="typeHandlers（类型处理器）"><a href="#typeHandlers（类型处理器）" class="headerlink" title="typeHandlers（类型处理器）"></a>typeHandlers（类型处理器）</h3><p>mybatis中通过typeHandlers完成jdbc类型和java类型的转换</p><p>通常情况下，mybatis提供的处理器满足日常需要，不需要自定义</p><h3 id="mappers（映射配置）"><a href="#mappers（映射配置）" class="headerlink" title="mappers（映射配置）"></a>mappers（映射配置）</h3><p>通过resource加载单个文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">maper</span> <span class="attr">class</span>/<span class="attr">resource</span>/<span class="attr">url</span>/ /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--通过mapper接口加载映射文件，需要将mapper接口的类名和mapper.xml映射文件的名称保持一致，且在一个目录，上边规范的前提是使用mapper代理的方法--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">maper</span> <span class="attr">class</span> /&gt;</span>指定的不是映射文件，指定的是class</span><br><span class="line"></span><br><span class="line">//批量加载mapper,指定mapper接口的包名，mybatis自动扫描包下的所有接口进行加载。这个遵循上面的规范</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span> = <span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="输入映射"><a href="#输入映射" class="headerlink" title="输入映射"></a>输入映射</h4><p>通过parameterType指定输入参数类型，类型可以实简单类型、hashmap、pojo的包装类型</p><p><strong>传递pojo的包装对象</strong>：</p><p>需求：完成用户信息的综合查询，需要传入查询条件很复杂（可能包含用户信息、其他信息，比如商品、订单的）</p><p>针对上面的需求建议使用自定义的pojo，自定义查询条件</p><h4 id="输出映射"><a href="#输出映射" class="headerlink" title="输出映射"></a>输出映射</h4><p><strong>resultType</strong>:</p><p>使用resultType进行输出映射，只有查询出来的列名和pojo的属性名一致，该列才可以映射成功。如果查询出来的列名和pojo中的属性名全部不一致，没有创建pojo对象。只要查询出来的列名和pojo中的属性有一个一致，就会创建一个pojo对象</p><p><strong>输出简单类型</strong>：用户信息的综合查询的列表总数，通过查询总数和上边用户综合查询列表才可以实现分页</p><p>小节：只有查询出来的只有一行且有一列才可以使用输出简单类型</p><p>输出pojo对象和pojo列表：不管输出的是pojo对象还是列表，在mapper.xml中resultType中指定的类型是一样的，但是在mapper.java中的返回值类型不一样（对象、集合），然后自动生成的mapper代理对象中是根据mapper方法的返回值类型确定是调用selectOne还是selectList</p><p><strong>resultMap</strong>：</p><p>mybatis中使用resultMap完成高级输出结果映射</p><p>使用方法：</p><p>如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间做一个映射关系</p><p>1.定义resultMap</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//id是resultMAp的唯一标识</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span> = <span class="string">""</span> <span class="attr">id</span> = <span class="string">""</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​//id表示查询结果的唯一标识 ，column sql语句中查询的列名，property：pojo中的属性名</span><br><span class="line"></span><br><span class="line">​<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span> = <span class="string">""</span> <span class="attr">property</span> = <span class="string">""</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>resultMap：给定义的resultMap的id，如果这个resultMap在其他的mapper文档中，前边需要加namespace    </p><p>2.使用resultMap作为statement的输出映射类型</p><p>将下边的sql用UserCostom完成映射</p><p>userCustom类中的属性和上边的查询列名不一致</p><p><strong>小节</strong>：</p><p>使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功，如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系</p><h4 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h4><h5 id="什么是动态sql"><a href="#什么是动态sql" class="headerlink" title="什么是动态sql"></a>什么是动态sql</h5><p>mybatis核心：对sql语句进行灵活的操作，通过表达式，对sql进行灵活判断，组装</p><p><strong>需求</strong>：</p><p>用户信息的综合查询列表和用户信息查询列表的总数 这两个statement的定义使用动态sql。对查询条件进行判断，查询条件不为空，我们才会对查询语句进行拼接</p><h5 id="if"><a href="#if" class="headerlink" title="if"></a>if</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//可以去掉查询条件中的第一个and</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//判断条件</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span> = <span class="string">"条件"</span>&gt;</span>sql语句<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><p>向sql传递数组或list，mybatis使用foreach解析</p><p>在用户查询列表和查询总数的statement中添加多个id输入查询</p><p>在输入参数类型中添加list<integer> ids传入多个id</integer></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//使用foreach遍历传入的ids</span><br><span class="line"></span><br><span class="line">//collections：指定输入对象中集合属性，item：每次遍历生成对象中的属性名，open：开始遍历时拼接的串，close：结束遍历时拼接串,separator:遍历的两个对象中间需要拼接的串</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collections</span> = <span class="string">""</span> <span class="attr">item</span> = <span class="string">""</span> <span class="attr">open</span> = <span class="string">"AND("</span> <span class="attr">close</span> = <span class="string">")"</span> <span class="attr">separator</span> = <span class="string">""</span>&gt;</span>id = #&#123;这里填的时item里面填的东西&#125;<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="sql片段"><a href="#sql片段" class="headerlink" title="sql片段"></a>sql片段</h5><p><strong>需求</strong>:</p><p>将上边实现的sql判断代码抽取出来，组成一个sql片段。其他的statement中就可以来引用这个sql片段</p><p>在mapper.xml中定义的statement的引用sql片段</p><p>1.定义sql</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//sql片段的唯一标识,一般我们定义sql片段是基于单表来定义的，这样的话可重用性高。在sql片段中不要包括where</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span> = <span class="string">""</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span> = <span class="string">"条件"</span>&gt;</span>sql语句<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.引用sql</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//引用sql片段的id，如果refid指定的id不再本mapper文件中，需要在前面加namespace</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span> = <span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​//在这里还要引用其他的sql片段，所以sql片段不能加where</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_mybatis_end</title>
      <link href="/2019/08/14/java/mybatis/end/"/>
      <url>/2019/08/14/java/mybatis/end/</url>
      
        <content type="html"><![CDATA[<h4 id="mybatis高级映射及开发方法"><a href="#mybatis高级映射及开发方法" class="headerlink" title="mybatis高级映射及开发方法"></a><center>mybatis高级映射及开发方法</center></h4><a id="more"></a><p><strong>课程复习</strong>：</p><p>mybatis是什么？mybatis和hibernate都是持久层框架，mybatis是一个不完全的ORM框架，sql语句需要程序员自己去编写，但mybatis也有映射（输入映射、输出映射）</p><p>mybatis入门门槛不高，学习成本低，让程序员把精力放在sql语句上，对sql语句优化非常方便，适用于需求变化较多的项目，比如互联网项目</p><p><strong>mybatis框架执行过程</strong>：</p><p>1.配置mybatis的配置文件，SqlMapConfig（名称不固定）</p><p>2.通过配置文件，加载mybatis运行环境，创建SqlSessionFactory会话工厂。SqlSessionFactory实际使用时按单列管理</p><p>3.通过工厂创建SqlSession</p><p>SqlSession是一个面向用户的接口（提供操作数据库的方法），实现对象是线程不安全的，建议SqlSession应用场合在方法体内</p><p>4.调用SqlSession的方法去操作数据库</p><p>如果需要提交事务，需要执行SqlSession的commit()方法</p><p>5.释放资源，关闭SqlSession</p><p><strong>mybatis开发dao的方法</strong>：</p><p>1.原始dao方法：需要程序员编写dao接口和实现类。需要在dao实现类中注入一个SqlSessionFactory工厂</p><p>2.mapper代理开发方法：</p><p>只需要程序员编写mapper接口（就是dao接口）</p><p>程序员在编写mapper.xml（映射文件）和mapper.java需要遵循一个开发规范</p><p>a.在mapper.xml中namespace就是mapper.java的全路径</p><p>b.mapper.xml中statement的id和mapper.java中的方法名一致</p><p>c.mapper.xml中statement的parameterType指定的参数类型和mapper.java中方法的输入参数类型一致</p><p>d.mapper.xml中statement的resultType指定的参数类型和mapper.java中方法的输出参数类型一致</p><p><strong>输入映射</strong></p><p>parameterType：指定输入参数的类型可以是简单类型、pojo、hashmap，对于综合查询，建议parameterType使用包装的pojo，有利于系统扩展</p><p><strong>输出映射</strong></p><p>resultType：查询道德列名和resultType指定的属性名一致，才能映射成功</p><p>resultMap：可以通过resultMap来完成高级的映射、复杂的映射，如果查询道德列名和pojo的属性不一致时，我们就可以通过resultMap来设置列名和属性名之间的映射关系。可以完成映射</p><p><strong>高级映射</strong></p><p>将关联查询的列映射到pojo的属性中（一对一）</p><p>将关联查询的列映射到List<pojo>中（一对多）</pojo></p><p><strong>动态sql</strong></p><p>if、where、foreach、sql片段</p><h2 id="订单商品数据模型分析"><a href="#订单商品数据模型分析" class="headerlink" title="订单商品数据模型分析"></a>订单商品数据模型分析</h2><h3 id="数据模型分析思路"><a href="#数据模型分析思路" class="headerlink" title="数据模型分析思路"></a>数据模型分析思路</h3><p>1.每张表记录的数据内容：分模块对每张表的内容进行熟悉，相当于你学习系统需求（功能）的过程</p><p>2.每张表重要数据字段设置：非空字段、有外键的字段</p><p>3.数据库级别表与表之间的关系：外键关系</p><p>4.表与表之间的业务关系：在分析表与表之间的业务关系时一定是建立在某个业务意义基础上去分析</p><p>先分析数据级别之间有关系的表之间的业务关系：</p><p>user和orders：</p><p>user—&gt;orders：一个用户可以创建多个订单，一对多</p><p>orders—&gt;user：一个订单可以由多个用户创建，一对一</p><p>orders和orderdetall：</p><p>orders—&gt;orderdetall：一个订单包含多个订单明细，一个订单可以购买多个商品，每个商品的购买信息都在orderdetail记录，一对多关系</p><p>orderdetall—&gt;orders：一个订单明细只能包括在一个订单中，一对一</p><h2 id="高级结果映射"><a href="#高级结果映射" class="headerlink" title="高级结果映射"></a>高级结果映射</h2><p><strong>一对一</strong></p><p>查询订单信息，关联查询创建订单用户信息</p><p>slq语句：查询订单信息，关联查询创建订单用户</p><p>resultType：</p><p>创建一个pojo让他字段名和属性名一一对应</p><p>创建的时候可以让他继承一下之前的pojo类，这样可以简化后台代码</p><p>resultMap：</p><p>使用resultMap将查询结果映射到Order对象中，在orders类中添加user属性，将关联查询出来的用户信息映射到orders对象中的user属性中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img 1565493794869.png This is an image %&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/1565493794869.png" alt></p><p>实体类orders里面的实体类user</p><p>association里面的标签是配置查询的列和user实体类对应的信息</p><p>id：关联查询用户的唯一标识</p><p>javaType：需要映射的那个实体类的路径（user）</p><p>column：指定用户信息的列</p><p>property：user中的属性名</p><p><strong>resultType和resultMap</strong></p><p>实现一对一查询：</p><p>resultType：使用resultType实现较为简单，如果pojo中没有包括查询的列名，需要增加与列名对应的属性，即可完成映射</p><p>如果没有查询结果的特殊要求建议使用resultType</p><p>resultMap：需要定义resultMap，实现有点复杂，如果对查询结果由特殊要求，使用resultMap可以完成将关联查询映射pojo的属性中</p><p>resulrMap可以实现延迟加载，而resultType无法实现延迟加载</p><p><strong>一对多</strong></p><p>查询订单及订单明细</p><p>sql语句：确定主查询表、确定关联查询表</p><p><strong>collection</strong>：一个订单关联出了多条明细，要使用collection进行映射。collection：对关联查询道德多条记录映射到集合对象中</p><p>property：将关联查询到的多条记录映射到集合对象的哪个属性中</p><p>ofType：集合对象的一条pojo对应的实体类的路径</p><p><strong>小结</strong></p><p>mybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性中</p><p>使用resultType实现：将订单明细映射到orders中的orderdetails中需要自己处理，使用双重循环遍历，去掉重复记录，将订单明细放在orderdetails</p><p><strong>多对多</strong></p><p><img src="/images/1565512910096.png" alt></p><p>总结：</p><p>将查询用户购买商品信息明细清单（用户名、用户地址、购买商品时间、购买商品数量）</p><p>针对上边的需求，将查询到的记录映射到扩展的pojo中，很简单实现明细清单的功能</p><p>使用resultMap对查询结果映射有特殊要求的功能</p><h2 id="mybatis延迟加载"><a href="#mybatis延迟加载" class="headerlink" title="mybatis延迟加载"></a>mybatis延迟加载</h2><p><img src="/images/1565576908107.png" alt></p><p><img src="/images/1565576954595.png" alt></p><p>使用association中的select指定延迟加载去执行statement的id</p><p>延迟加载是什么？先执行简单查询语句，有条件的话，利用association来执行副表查询语句。减轻数据库的压力</p><p>不适用mybatis提供的association及collection中的延迟加载功能，如何实现延迟加载</p><p>实现方法如下：先去查询一个mapper方法，获取第一个mapper查询的订单信息。在程序中，按需去调用第二个mapper方法去查询用户信息</p><p>使用延迟加载是为了，先查询简单的sql，再去按需加载关联查询的其他信息</p><h2 id="mybatis查询缓存"><a href="#mybatis查询缓存" class="headerlink" title="mybatis查询缓存"></a>mybatis查询缓存</h2><p><strong>一级缓存</strong>：sqlSession级别的缓存，在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMAp）用于存储数据。不同的sqlSession之间缓存数据区域（HashMap）是互相不影响的</p><p><strong>二级缓存</strong>：mapper级别的缓存：多个sqlSession去操作同一个Mapper的sql语句，多个sqlSession可以共用二级缓存，二级缓存可以跨sqlSession的</p><p>为什么要用缓存？</p><p>如果存储中有数据就不用从数据库中获取，大大提高系统性能</p><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>第一次发起查询用户id位1的用户信息，先去缓存中查询是否有id为1的用户信息，如果没有，从数据库查询用户信息</p><p>得到用户信息，将用户信息存储到一级缓存中</p><p>第二次发起查询用户id位1的用户信息，先去缓存中查询是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息</p><p>如果sqlSession去执行commit操作（去执行、更新、删除），清空sqlSession中的一级缓存，这样做的目的是为了让缓存中的信息存储的是最新的信息，避免脏读</p><p>mybatis默认支持一级缓存，不需要在配置文件中去开启缓存</p><h3 id="一级缓存的应用"><a href="#一级缓存的应用" class="headerlink" title="一级缓存的应用"></a>一级缓存的应用</h3><p>正式开发：是将spring和mybatis进行整合开发，事务控制在service中</p><p>一个service方法中包括很多mapper方法调用</p><p>service：</p><p>开始执行时，开启事务，创建sqlSession对象</p><p>第一次调用mapper的方法。</p><p>第二次调用mapper的方法，从一级缓存中拿数据</p><p>方法结束，sqlSession关闭</p><p>如果执行两次service调用查询相同的用户信息，不走一级缓存，因为session方法结束，sqlSession就关闭，一级缓存就清空</p><p>这样的话，我们就需要学习二级缓存</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>首先要手动开启mybatis的二级缓存</p><p>sqlSession1去查询用户id为1的用户信息，查询到用户信息会将查询数据存储到二级缓存中</p><p>sqlSession2去查询用户id为1的用户信息，先去缓存中查找是否存在数据，如果存在直接从缓存中取出数据。</p><p>如果执行了commit的话，那么就会清空mapper对应的二级缓存下的数据</p><p><code>二级缓存和一级缓存的区别</code>，二级缓存的范围更大，多个sqlSession可以共享一个UserMapper的二级缓存区域。UserMapper有一个二级缓存区域，其他的Mapper也有缓存区域（按照namespace分的）。也就是说每一个namespace的mapper有一个二级缓存区域，两个mapper的namespace如果相同，那么这两个mapper执行sql查询到的数据将存储在相同的二级缓存区域中</p><h3 id="开启二级缓存"><a href="#开启二级缓存" class="headerlink" title="开启二级缓存"></a>开启二级缓存</h3><p>mybatis的二级缓存是mapper范围级别，除了在SqlMapConfig.xml设置二级缓存的总开关，还要再具体的mapper.xml中开启二级缓存</p><p>在UserMapper.xml中开启二级缓存，UserMapper.xml下的sql执行完成后会存储到他的缓存区域（HashMap）</p><p>开启本Mapper namespace下的二级缓存：<cache></cache></p><p>调用pojo类实现序列化接口：为了将缓存数据取出执行反序化操作，因为二级缓存数据介质多种多样，不一定在内存</p><h3 id="禁用二级缓存"><a href="#禁用二级缓存" class="headerlink" title="禁用二级缓存"></a>禁用二级缓存</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">userCatch</span> = <span class="string">"false"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样配置的话，这条语句每次都会去数据库查询，禁用二级缓存。针对每次查询都需要最新的数据sql</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般情况下，执行完commit操作都需要刷新缓存，flushCache = “true”代表刷新缓存，这样可以避免数据库脏读</p><h3 id="刷新缓存"><a href="#刷新缓存" class="headerlink" title="刷新缓存"></a>刷新缓存</h3><p>刷新缓存是清空缓存，在mapper的同一个namespace中，如果有其他insert、update、delete操作后需要刷新缓存，如果不刷新缓存就会出现脏读</p><p>设置statement配置中的flushCache = “true”属性，默认情况下为true即刷新缓存，如果改成false则不会刷新。使用缓存时会出现脏读,如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span> = <span class="string">"insertUser"</span> <span class="attr">parameterType</span> = <span class="string">"User"</span> <span class="attr">flushCache</span> = <span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="mybatis整合ehcache"><a href="#mybatis整合ehcache" class="headerlink" title="mybatis整合ehcache"></a>mybatis整合ehcache</h3><p>ehcache是一个分布式缓存框架</p><h4 id="分布缓存"><a href="#分布缓存" class="headerlink" title="分布缓存"></a>分布缓存</h4><p>我们的系统为了提高系统并发、性能，一般对系统进行分布式部署（集群部署方式）</p><p>不使用分布缓存，缓存的数据在各个服务单独存储，不方便开发。所以要使用分布式缓存对缓存数据进行集中管理</p><p>对缓存数据集中管理，我们要使用分布式缓存框架redis、memcached、ehcache</p><p>mybatis无法实现分布式缓存，不利于系统开发，需要和其他的分布式缓存框架进行整合</p><h4 id="整合的方法"><a href="#整合的方法" class="headerlink" title="整合的方法"></a>整合的方法</h4><p>mybatis提供了一个cache接口，如果要实现自己的缓存逻辑，实现自己的cache接口即可</p><p>mybatis和ehcache整合，mybatis和ehcache整合包中提供了一个cache接口的实现类</p><p>mybatis有默认实现的cache类</p><p>整合eacache：</p><p>1.导入包</p><p>2.实现cache类（配置mapper中的type为ehcache接口的实现类型）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span> = <span class="string">"org.mybatis.caches.ehcache.EhcacheCache"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="加入ehcache的配置文件"><a href="#加入ehcache的配置文件" class="headerlink" title="加入ehcache的配置文件"></a>加入ehcache的配置文件</h4><p><img src="/images/1565593058004.png" alt></p><p>在classpath下配置ehcache.xml</p><h3 id="二级缓存的应用场景"><a href="#二级缓存的应用场景" class="headerlink" title="二级缓存的应用场景"></a>二级缓存的应用场景</h3><p>对于访问多的查询请求且用户对查询结果实时要求不高，此时可以采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景如下：耗时较高的统计分析sql、电话账单查询sql等</p><p>实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新时间隔fulshInterval，比如设置为30分钟、60分钟、24小时等</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下要求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都查询最新的商品信息，此时如果使用二级缓存就无法实现一个商品变化时只刷新该商品的缓存信息而不刷新其他商品的信息，因为mybatis的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有的商品信息的缓存数据全部清空。解决此类问题需要在服务层根据需求对数据进行有针对性的缓存</p><h2 id="mybatis和spring进行整合"><a href="#mybatis和spring进行整合" class="headerlink" title="mybatis和spring进行整合"></a>mybatis和spring进行整合</h2><h3 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h3><p><strong>需要spring通过单列方式管理SqlSessionFactory</strong></p><p>spring和mybatis整合生成代理对象，使用SqlSessionFactory创建SqlSession（spring和mybatis整合自动完成）</p><p><strong>持久层的mapper都需要由spring进行管理</strong></p><h3 id="整合环境"><a href="#整合环境" class="headerlink" title="整合环境"></a>整合环境</h3><p>创建一个新的java工程（接近实际开发的工程结构）</p><p>jar包：</p><p>mybatis3.2.7的jar包</p><p>spring3.2.0的jar包</p><p>mybatis和spring的整合包：早期ibatis和spring整合是由spring官方提供，mybatis和spring整合由mybatis提供</p><h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p><strong>在applicationContext.xml中配置sqlSessionFactory和数据源</strong></p><p>sqlSessionFactory在mybatis的spring的整合包下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据源，使用dbcp或者（c3p0）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="attr">destory-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="原始dao开发"><a href="#原始dao开发" class="headerlink" title="原始dao开发"></a>原始dao开发</h3><h4 id="mapper-xml"><a href="#mapper-xml" class="headerlink" title="mapper.xml"></a>mapper.xml</h4><p>创建mapper.xml</p><p>在SqlMapConfig.xml中加载User.xml</p><h4 id="dao"><a href="#dao" class="headerlink" title="dao"></a>dao</h4><p>dao接口实现需要注入SqlSessionFactory，通过spring进行注入</p><p>这里为了更好的让大家看见，这里用spring声明配置方式，配置dao的bean</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao class="</span><span class="attr">cn.itcast.ssm.dao.UserDaoImpl</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">ref</span>=<span class="string">"SessionFactory"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>让UserDaoImpl实现类继承SqlSessionDaoSupport（extends SqlSessionDaoSupport ）。继承的这个东西里面有创建会话工厂的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承了这个东西之后，创建会话的方法</span></span><br><span class="line">SqlSession sqlSession = <span class="keyword">this</span>.getSqlSession();</span><br></pre></td></tr></table></figure><p>在applicationContext.xml中配置dao</p><h3 id="mapper代理开发"><a href="#mapper代理开发" class="headerlink" title="mapper代理开发"></a>mapper代理开发</h3><h4 id="mapper-xml-1"><a href="#mapper-xml-1" class="headerlink" title="mapper.xml"></a>mapper.xml</h4><h2 id="mybatis逆向工程"><a href="#mybatis逆向工程" class="headerlink" title="mybatis逆向工程"></a>mybatis逆向工程</h2><h3 id="什么是逆向工程？"><a href="#什么是逆向工程？" class="headerlink" title="什么是逆向工程？"></a>什么是逆向工程？</h3><p>mybatis需要程序员自己写sql语句，mybatis官方提供逆向工程，针对单表来生成代码，mybatis执行所需要的代码（mapper.java\mapper.xml\po）</p><p>企业的实际开发中，常用的逆向工程方式</p><p>由于数据库的表生成java代码</p><h3 id="下载逆向工程"><a href="#下载逆向工程" class="headerlink" title="下载逆向工程"></a>下载逆向工程</h3><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>建议使用java程序方式，不依赖开发工具</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/13/hello-world/"/>
      <url>/2019/08/13/hello-world/</url>
      
        <content type="html"><![CDATA[<h4 id="welcome"><a href="#welcome" class="headerlink" title="welcome"></a><center>welcome</center></h4><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
